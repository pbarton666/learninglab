@An immersive fast-track guide@Patrick Barton@Portland Energy Strategies Laboratories CoursewareWelcome!@--------<S-CR>This course will take you on a journey through the world of Python 3.0.@Whether you are new to programming or just new to Python, expect to come@away with a solid understanding of:<S-CR>-   What the heck is Python and where did it come from?<S-CR>-   Interacting with Python at the command line (Python is really@    gregarious!)<S-CR>-   Working effectively with an interactive debugging environment<S-CR><!-- --><S-CR>-   Utilizing professional code distributions and package managers<S-CR>-   Python objects including classes, methods, and collections<S-CR>-   Customizing your Python objects with your own code<S-CR>This might sound like a lot – and it is. But Python really is fun to@work with and very forgiving to the beginner. You can’t break Python. It@talks to you. In fact, it’s downright loquacious. You can ask it@questions and it (usually) provides sensible answers. And when it@doesn’t, there are hundreds of thousands of great resources available@over the internet. We’ll show you how to access some of these, as well.@So roll up your sleeves and get ready to enjoy the ride!<S-CR>The Python Environment@----------------------<S-CR>You should already have Python installed on your machine. If not, no@worries. You could go ahead and install a fresh Python distribution and@an IDE (integrated development environment).<S-CR>Yes, it’s possible to download, compile, and install Python. If you’re@ever interested, downloads are available directly from the official@Python web site:<S-CR>https://www.python.org/downloads.<S-CR>This being said, there are distributions such as EnThought and Anaconda@which offer integrated package management that allows easy access to@extended libraries and their sometimes extensive/tedious dependencies.@This is especially valuable when adding complex libraries such as NumPy,@which can take hours to get right.<S-CR>For this course, we’ll use the Anaconda distribution. This supports all@sorts of data science and visualization packages that we’ll touch on in@the advanced course, along with Python virtual environments “right out@of the box.” You can install it by browsing to this sight and following@the instructions to get the 64-bit version for Python 3.<S-CR>https://www.anaconda.com/download/<S-CR>The “official” IDE for Python is called IDLE. It provides a rudimentary@and very light weight debugger and file manager. IDLE works and works@well, but for serious work I much prefer a more fully-functional@environment such as PyCharm or WingIDE. If you’re accustomed to Eclipse,@you could use the PyDev plug-in[1]. A light-weight debugger, Spyder,@comes packaged with Anaconda. If you want to use Wing, you can download@a full-on Professional version (free for 30 days)[2]. You have many@options.<S-CR>Python uses environment variables to help it work and play well with the@operating system (OS). The most important of these are PATH and@PYTHONPATH.<S-CR>PATH contains the directories your OS will search when looking for a@particular application. In order for Python to “just work” when you@type:<S-CR>\$ python<S-CR>… you have to include Python’s binary (executable) directory in the PATH@variable. That’s where python.exe lives. On a Windows system, you can do@that by clicking:  @**Start ... Control Panel... System ... Advanced System Settings ...@Environment Variables**<S-CR>Then edit PATH by appending the binary directory. You have to be a bit@careful. Add a semicolon, no spaces, and the name of the new directory@with no trailing slash. Something like:<S-CR>\<existing path\>;c:\\Path\\To\\Directory<S-CR>On a Linux system, you can simply add an export to \~/.bashrc:<S-CR>Export PATH = \$PATH:/path/to/directory<S-CR>PYTHONPATH works the same way PATH does, but it’s used internally by@Python to search for modules (libraries, for instance) that you’ll want@to import into your code’s namespace.<S-CR>Once you make the necessary changes to your environment variables,@you’ll need to start a new terminal to apply them (or run source@\~/.bashrc in Linux).<S-CR>Some Basics @-----------<S-CR>Let’s have a quick look at some Python concepts. We’ll cover all these@in more depth later, but we’ll put them on the table early.<S-CR>Python is an amazingly simple language from a syntax perspective.@Believe it or not, there are only 33 keywords only a few of which are@exotic. Here’s a list[3]:<S-CR>|        |          |         |          |        |@|--------|----------|---------|----------|--------|@| False  | class    | finally | is       | return |@| None   | continue | for     | lambda   | try    |@| True   | def      | from    | nonlocal | while  |@| and    | del      | global  | not      | with   |@| as     | elif     | if      | or       | yield  |@| assert | else     | import  | pass     |        |@| break  | except   | in      | raise    |        |<S-CR>Let’s have a quick look at some Python concepts. We’ll cover all these@in more depth later, but we’ll put them on the table early.<S-CR>If you are ever uncertain about whether a variable name you’re@considering is a keyword (or otherwise known to the interpreter), you@can just type it into a command line. If the interpreter “yells at you”,@you can choose another name.<S-CR>A few other things to know:<S-CR>-   Case matters – Python is case sensitive<S-CR>-   Indentation matters – Python doesn’t rely on brackets or braces<S-CR>-   Whitespace typically does not matter<S-CR>-   Help is just a few keystrokes away – just type “help”<S-CR>So, what is Python, anyway?<S-CR>-   A **high-level**, **object oriented** (each object has its own@    repertoire of nouns and verbs, and they can borrow from and build on@    each other) **interpreted** language (“just in time” compilation).<S-CR>-   You can think of it a giant wrapper around hundreds of thousands of@    lines of C and C++ libraries, each providing consistent APIs@    (Application Programming Interfaces) so everything has the same look@    and feel.<S-CR>-   Created by **Guido van Rossum**, a great fan of **Monty Python**, in@    the late 1990s as a successor to the ABC language, with significant@    support from **DARPA**. (That’s Guido holding a beer in the photo@    below.)<S-CR>-   Highly extensible to applications such as GIS (pyqgis), scientific@    programming (numpy), visualization (matplotlib), and many other@    domains.<S-CR>-   Python is operating system agnostic, and runs equally well on@    Windows, Linux, Raspberry Pi, and Mac systems.<S-CR>Python has been around since 1994 and has undergone several@transformations. Most notably, Python evolved from 2.7 to 3.0 in 2008,@implementing Unicode characters and addressing some lingering structural@concerns.<S-CR>There are plenty of solid applications written in 2.7 in the world, but@most newer developments have shifted to Python 3. You should be aware@that there are enough substantive differences between 2.x and 3.x that@code written against one version is not wholly compatible with the@other.<S-CR>By design Python is simple, clear, and transparent. Philosophical@tenants (shown in abbreviated form here) are always available:<S-CR>> <img src="attachment:media/image3.gif" style="width:3.45903in;height:3.0303in" />\>\>\>@> import this@>@> The Zen of Python, by Tim Peters@>@> Beautiful is better than ugly.@>@> Explicit is better than implicit.@>@> Simple is better than complex.@>@> Complex is better than complicated.@>@> Flat is better than nested.@>@> Sparse is better than dense.@>@> Readability counts.@>@> Special cases aren't special enough to break the rules.@>@> Although practicality beats purity.@>@> Errors should never pass silently.@>@> Unless explicitly silenced.@>@> In the face of ambiguity, refuse the temptation to guess.@>@> There should be one-- and preferably only one --obvious way to do it.@>@> Although that way may not be obvious at first unless you're Dutch.@>@> Now is better than never.@>@> Although never is often better than \*right\* now.@>@> If the implementation is hard to explain, it's a bad idea.@>@> If the implementation is easy to explain, it may be a good idea.@>@> Namespaces are one honking great idea -- let's do more of those!.<S-CR>OK. Let’s get started and have some fun!<S-CR>Basic Python Syntax@===================<S-CR>Hello, Python@-------------<S-CR>As you know, there’s an unwritten Cosmic Law stating all computer@courses have to start with a “Hello World” application. Since we don’t@want the Cosmic Police kicking the door down, let’s start with that.@Besides, it’s a great introduction to Python’s command line operations.<S-CR>To invoke the interpreter, type this from the command line (except the@“\$”):<S-CR>\$ python3<S-CR>… which should get you something this:<S-CR>Python 3.3.0 (default, Sep 5 2016, 11:33:57)<S-CR>\[GCC 4.8.4\] on linux<S-CR>Type "help", "copyright", "credits" or "license" for more information.<S-CR>So what’s this? The first few lines let you know what “flavor” of Python@you’re using, and how it was compiled. This can be important because you@may well have several versions installed on the same machine. More on@that later.<S-CR>The last line is the interpreter’s prompt to let you know you’re talking@to Python. So let’s say “hello.”<S-CR>|                               |@|-------------------------------|@| \>\>\> print("Hello, Python") |@| Hello, Python                 |<S-CR>In this command, we utilize one of Python’s top-level methods, the@**print function,** and one of Python’s top-level objects, the string,@known internally as a **str**. Note that the arguments to the function@are enclosed in parentheses, and that the contents of the string are@enclosed in quotes.<S-CR>Strings are ubiquitous, so it’s good to know a few ways to compose them.@Here are some examples. These are annotated using the **\#** character –@that’s how you can make single line comments. Anything to the right of@the \# will not compile, so you can embed your comments in-line.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#you can use double quotes – useful with apostrophes</p>@<p>&gt;&gt;&gt; print("Hello, Guido’s cool project")</p></td>@</tr>@<tr class="even">@<td><p>Hello, Guido’s cool project</p>@<p>#you can also “escape” the apostrophe with a “\”</p></td>@</tr>@<tr class="odd">@<td>&gt;&gt;&gt; print("Hello, Guido\’s cool project")</td>@</tr>@<tr class="even">@<td>Hello, Guido’s cool project</td>@</tr>@</tbody>@</table><S-CR>Let’s try a few more strings. This time, we’ll assign them to names so@wrangling them will be easier. So what are names? These are just tags@you can associate with values. “Values” are simply the bits of@information stored in the computer’s memory.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#single quotes work just fine</p>@<p>&gt;&gt;&gt; team = ‘Cubs’</p>@<p>#you can also use triple double quotes</p></td>@</tr>@<tr class="even">@<td><p>&gt;&gt;&gt; year = """2018"""</p>@<p>#... or triple single quotes</p></td>@</tr>@<tr class="odd">@<td>&gt;&gt;&gt; outcome = ‘‘‘win’’’</td>@</tr>@<tr class="even">@<td>#these can be provided to print as <strong>arguments</strong>, separated by commas.</td>@</tr>@<tr class="odd">@<td>&gt;&gt;&gt; print(team, year, outcome)</td>@</tr>@<tr class="even">@<td>Cubs 2018 win</td>@</tr>@</tbody>@</table><S-CR>You can provide a series of strings together and Python will@automatically concatenate them (run them together):<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; "and" "a" "one" "and" "a" "two"</p>@<p>‘andaoneandatwo’</p></td>@</tr>@</tbody>@</table><S-CR>If you ever want a multi-line string, you can use either of the triple@quote styles.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; chant = """Cubs</p>@<p>... 2018</p>@<p>... win"""</p>@<p>&gt;&gt;&gt; print(chant)</p>@<p>Cubs</p>@<p>2018</p>@<p>win</p></td>@</tr>@</tbody>@</table><S-CR>If you study the above example carefully, you’ll notice a couple@features. In the second line, the prompt changed from the usual “\>\>\>”@to ”...” This is the interpreter letting you know that it’s expecting@more input, and we were able to enter the multi-line string . This is@one of the kind features about Python. The interpreter will@automatically allow a command to be broken up into several lines if@there’s an unclosed control symbol. Since we had not yet included the@terminating triple quote, it patiently waited. This feature also works@for parentheses, braces, etc.<S-CR>Here is another example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#we’ll introduce the list object soon</p>@<p>&gt;&gt;&gt; a_list = [99,</p></td>@</tr>@<tr class="even">@<td>... 33,</td>@</tr>@<tr class="odd">@<td>... 40</td>@</tr>@<tr class="even">@<td>... ]</td>@</tr>@<tr class="odd">@<td>&gt;&gt;&gt; a_list</td>@</tr>@<tr class="even">@<td><p>[99, 33, 40]</p>@<p>&gt;&gt;&gt; exit() #returns to the OS command prompt</p></td>@</tr>@</tbody>@</table><S-CR>You now know how to communicate with Python’s command line. You can@execute functions, create objects, provide commands, and receive output.@Now, it’s time to roll your sleeves up.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise:</p>@<p>Please write your own version of a “hello world”, working at the terminal. Practice using all four of the string composition methods, and with both single and multiple line versions.</p>@<p>NOTE: The solutions appear in the course project folder, all beginning with “solution_python1”. You’re encouraged solve the challenge on your own – mistakes are part of the game, after all – but they are a resource if you need a hint.</p></td>@</tr>@</tbody>@</table><S-CR>What’s Your Number?@-------------------<S-CR>Do you remember when I said that Python is loquacious? I was not@kidding. You can have an interactive conversation with the interpreter@in which it will tell you about itself and all the objects it knows@about. The best part is that you can ask it for help and get reliable@information to guide your programming efforts.<S-CR>No course can teach you everything you need to know, not even this one.@Knowing how to efficiently get the help you need is perhaps the most@important skill you can acquire. So the information in this chapter is@the most critical bit of the course.<S-CR>The interpreter can tell you about itself. Sometimes you have to access@built-in libraries by importing them into your local **namespace**. A@namespace is all the names (“tags”), associated with the **values**@stored in memory, your program has access to. By importing more names,@we have access to more values and objects.<S-CR>Here, we’re asking the interpreter what version of Python we’re using,@which release, and what operating system it finds itself operating@within.<S-CR>Let’s have a conversation!<S-CR><table>@<thead>@<tr class="header">@<th>&gt;&gt;&gt; import sys #tools for working with the Python environment</th>@</tr>@</thead>@<tbody>@<tr class="odd">@<td>&gt;&gt;&gt; sys.version</td>@</tr>@<tr class="even">@<td>‘3.3.0 (default, Sep 5 2016, 11:33:57) \n[GCC 4.8.4]’</td>@</tr>@<tr class="odd">@<td>&gt;&gt;&gt; sys.version_info</td>@</tr>@<tr class="even">@<td><p>sys.version_info(major = 3, minor = 3, micro = 0,</p>@<p>releaselevel = ‘final’, serial = 0)</p></td>@</tr>@<tr class="odd">@<td>&gt;&gt;&gt; import os #tools for working with the OS (Linux here)</td>@</tr>@<tr class="even">@<td>&gt;&gt;&gt; os.name</td>@</tr>@<tr class="odd">@<td>‘posix’</td>@</tr>@</tbody>@</table><S-CR>Now, this gets even better. Let’s say we have an object. “One is the@loneliest number that there ever was”, or so the song goes. Maybe we can@address the issue by engaging with 1 – or maybe we can’t, but let’s try.@To start with we’ll give it the name “one”, pull up a chair, then chat@it up.<S-CR><table>@<thead>@<tr class="header">@<th>&gt;&gt;&gt; one = 1 # hey, can I call you ‘one’?</th>@</tr>@</thead>@<tbody>@<tr class="odd">@<td>&gt;&gt;&gt; one # tell me a little about yourself</td>@</tr>@<tr class="even">@<td>1</td>@</tr>@<tr class="odd">@<td><p>&gt;&gt;&gt; id(one) # where do you live?</p>@<p>8961856</p>@<p>&gt;&gt;&gt; type(one) #I like your type. What is it, anyway?</p>@<p>&lt;class ‘int’&gt;</p>@<p>&gt;&gt;&gt; isinstance(one, str) #Did you say you were a string?</p>@<p>False</p>@<p>&gt;&gt;&gt; isinstance(one, int) #Um. Right, then an integer?</p>@<p>True</p></td>@</tr>@</tbody>@</table><S-CR>Let’s step through this preliminary conversation. After we assigned it a@name, we then called it by name and it responded. It happened to respond@with its value, but not all objects do that. The response is built into@the object as its **\_\_repr\_\_** method, which is executed when you@type the name. When you make your own classes later on, you’ll be able@to make it say something like “I’m 1, and I’m a Leo”, or anything else@you like. The **int** object simply replies with a parsimonious string@representation of itself.<S-CR>The next bit, invoking the top level function **id** provides a unique@descriptor of the object. Under the hood, it’s just the location in@memory where the object resides (that’s how it’s guaranteed to be unique@– no two objects can occupy the same space at the same time).<S-CR>We’re pretty sure what type of object one is, but we can ask to be sure@using the **type** method. In this case, we learn that it’s an **int**@object (not an “integer”). In fact, **int** is the name of a built-in@function and already reserved by Python. We can use it with the@**isinstance** method to verify its type. This can become important –@for instance, we might want to check whether an object is a number@before attempting to do math with it.<S-CR>One of the really useful aspects of Python is that objects come to us@already endowed with properties and already knowing how to do@type-appropriate tricks. More properly these are called **attributes**@and **methods** (“nouns” and “verbs”). We can discover some of these@empirically, so let’s experiment:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; one+one #can you add?</p>@<p>2</p>@<p>&gt;&gt;&gt; one/ one #divide?</p>@<p>1.0</p>@<p>&gt;&gt;&gt; one* one #OK then, can you multiply?</p>@<p>1</p>@<p>&gt;&gt;&gt; one** one #do powers?</p>@<p>1</p>@<p>&gt;&gt;&gt; one% one #how about modulo operations?</p>@<p>0</p></td>@</tr>@</tbody>@</table><S-CR>This is pretty much as expected, since we’re already familiar with@integers. But we’ll frequently encounter objects that we’re not familiar@with, or need to know how they handle various operators. Sometimes@things aren’t as expected. For instance, what happens if we do a@“multiplication” or “addition” operation on a string?<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; "go"+"cubs"</p>@<p>‘gocubs’</p>@<p>&gt;&gt;&gt; "cubs"*10</p>@<p>‘cubscubscubscubscubscubscubscubscubscubs’</p></td>@</tr>@</tbody>@</table><S-CR>Getting Help@------------<S-CR>Though it’s interesting and really informative to experiment, you’ll@typically be too busy to indulge. In these cases, the most@straightforward way to engage is to ask for help. This is easy enough to@accomplish as you can see below. (Note I’ve edited out most of the five@pages of output, but I encourage you to browse through it).<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; help(one)</p>@<p>help(one)</p>@<p>Help on int object:</p>@<p>class int(object)</p>@<p>| int(x = 0) -&gt; integer</p>@<p>| int(x, base = 10) -&gt; integer</p>@<p>| |</p>@<p>&lt;snip&gt;</p></td>@</tr>@</tbody>@</table><S-CR>Another way to get information quickly is to use the built-in **dir**@method on the object. The output is a little harder to interpret,@especially when you’re looking at it for the first time, but you can get@a fairly compact look at the contents of the object’s **namespace**.@Let’s check it out, and I’ll explain some of the bits and pieces below.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dir(one)</p>@<p>[‘__abs__’, ‘__add__’, ‘__and__’, ‘__bool__’, ‘__ceil__’, ‘__class__’, ‘__delattr__’, ‘__dir__’, ‘__divmod__’, ‘__doc__’, ‘__eq__’, ‘__float__’, ‘__floor__’, ‘__floordiv__’, ‘__format__’, ‘__ge__’, ‘__getattribute__’, ‘__getnewargs__’, ‘__gt__’, ‘__hash__’, ‘__index__’, ‘__init__’, ‘__int__’, ‘__invert__’, ‘__le__’, ‘__lshift__’, ‘__lt__’, ‘__mod__’, ‘__mul__’, ‘__ne__’, ‘__neg__’, ‘__new__’, ‘__or__’, ‘__pos__’, ‘__pow__’, ‘__radd__’, ‘__rand__’, ‘__rdivmod__’, ‘__reduce__’, ‘__reduce_ex__’, ‘__repr__’, ‘__rfloordiv__’, ‘__rlshift__’, ‘__rmod__’, ‘__rmul__’, ‘__ror__’, ‘__round__’, ‘__rpow__’, ‘__rrshift__’, ‘__rshift__’, ‘__rsub__’, ‘__rtruediv__’, ‘__rxor__’, ‘__setattr__’, ‘__sizeof__’, ‘__str__’, ‘__sub__’, ‘__subclasshook__’, ‘__truediv__’, ‘__trunc__’, ‘__xor__’,</p>@<p>‘bit_length’, ‘conjugate’, ‘denominator’, ‘from_bytes’, ‘imag’, ‘numerator’, ‘real’, ‘to_bytes’]</p></td>@</tr>@</tbody>@</table><S-CR>The strange looking names that are surrounded by the “\_\_” characters@(which some call “dunder”, for “double underscore”) are mostly methods@that implement logic to make operational characters like “+” or “\<.” In@general, any name beginning with one or more “\_” characters is intended@for the object’s internal usage. You can access these, of course, but@you’ve been warned.<S-CR>The plain-text names are designed for “public consumption.” You can@learn more about them by slogging through the verbose help, asking for@help on a more narrow topic, or just by typing them in at the command@line, something like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; one.denominator</p>@<p>1</p>@<p>&gt;&gt;&gt; one.real</p>@<p>1</p>@<p>&gt;&gt;&gt; one.from_bytes</p>@<p>&lt;built-in method from_bytes of type object at 0x8685e0&gt;</p>@<p>&gt;&gt;&gt; help(one.from_bytes)</p>@<p>Help on built-in function from_bytes:</p>@<p>from_bytes(...)</p>@<p>int.from_bytes(bytes, byteorder, *, signed = False) -&gt; int</p>@<p>Return the integer represented by the given array of</p>@<p>bytes. &lt;snip&gt;</p></td>@</tr>@</tbody>@</table><S-CR>You’ll recall that when you simply type the name of an object into the@command line, you’re asking it to describe itself by invoking its@**\_\_repr\_\_** method. This is one of Python’s so-called “magic@methods” which are baked into the object with specific names that are@meaningful to the interpreter. As another example, the **\_\_str\_\_**@method is invoked when you use the object as an argument to the@**print** method.<S-CR>Here’s a list of some of the other “magic methods”, along with their@meanings. From the **dir** listing, we can see that most of these are@baked into the **int** object. We’ll actually be writing our own@versions of some these later in the course, but for now, here’s an@overview of the math operations.<S-CR>| addition                | x + y       | x.\_\_add\_\_(y)      |@|-------------------------|-------------|-----------------------|@| bitwise and             | x & y       | x.\_\_and\_\_(y)      |@| bitwise or              | x \| y      | x.\_\_or\_\_(y)       |@| bitwise xor             | x ^ y       | x.\_\_xor\_\_(y)      |@| division                | x / y       | x.\_\_truediv\_\_(y)  |@| floor division          | x // y      | x.\_\_floordiv\_\_(y) |@| floor division & modulo | divmod(x,y) | x.\_\_divmod\_\_(y)   |@| left bit-shift          | x \<\< y    | x.\_\_lshift\_\_(y)   |@| modulo (remainder)      | x % y       | x.\_\_mod\_\_(y)      |@| multiplication          | x \* y      | x.\_\_mul\_\_(y)      |@| raise to power          | x \*\* y    | x.\_\_pow\_\_(y)      |@| right bit-shift         | x \>\> y    | x.\_\_rshift\_\_(y)   |@| subtraction             | x - y       | x.\_\_sub\_\_(y)      |<S-CR>You’ll note that the **help** method is not within the namespace of the@objects. That’s because **help** is a top-level method. It works by@ransacking the object for what are called its **docstrings** – these are@provided by the programmer. They survive compilation so are carried with@the object itself, and can be whatever the programmer wants them to be.@By contrast, comments do not survive compilation and exist mostly as@developer-to-developer notes.<S-CR>**Docstrings** are simply the first executable line(s) of code in an@object, assuming a couple of things: the line(s) of code is a **str**@object, and the **str** object is not associated with a name. A quick@example should serve to clarify.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; def my_first_function():</p>@<p>... "the most simple function on Earth"</p>@<p>...</p>@<p>&gt;&gt;&gt; help(my_first_function)</p>@<p>Help on function my_first_function in module __main__:</p>@<p>my_first_function()</p>@<p>the most simple function on Earth</p>@<p>(END)</p></td>@</tr>@</tbody>@</table><S-CR>Here, the built-in **help** method simply picked off the docstring and@served it up as content within its delivery system (which is just like@**man** to deliver manual pages in a Posix system).<S-CR>Had this function been a method within a containing object like a class,@the help system would provide all available docstrings in the containing@object. That’s what happened when we used **help**(**one**) – we got all@the docstrings for the methods and attributes within the **int** class.<S-CR>While the built-in functionality typically serves well, sometimes it’s@necessary to go outside your code or use libraries that support@introspection of your objects[4]. Python has exceptionally well-written@official documentation that’s available at:<S-CR><http://python.org/3><S-CR>One word of caution – at the top-left of the Python docs web page,@you’ll see a small scroll-down menu with a number in it. It will look@something like this:<S-CR><img src="attachment:media/image4.gif" style="width:4.66in;height:0.52in" /><S-CR>The number is the version of Python addressed by the main page’s@contents. It’s quite easy to follow a link from a StackOverflow posting@(say) that vectors into the wrong version. Among versions of Python3 it@usually won’t matter, but there are significant differences between 2.x@and 3.x and you could waste a lot of time trying to get the wrong@material to work.<S-CR>Numbers and More Numbers@------------------------<S-CR>There are only two other numeric types within the core Python language,@the **float** and **complex** types. There are some exotic types in@external libraries such as decimal, such as **Fraction** (for real@numbers) and **Decimal** (for arbitrary levels of precision)[5].<S-CR>The **float** type is pretty much what you would expect – it’s anything@with a decimal point. Here’s an example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; root_beer = 1.0</p>@<p>&gt;&gt;&gt; type(root_beer)</p>@<p>&lt;class ‘float’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>Unless you’re an electrical engineer or a glutton for punishment, you@probably have little to do with “complex numbers.” They’re not all that@complex, but require two components. The first is “real” – an ordinary@number that stands on its own feet – and the second is “imaginary” – a@number that’s multiplied by the square root of -1. Yes, that’s where it@gets weird, but it’s beyond the scope of this class. Here’s one way to@specify a **complex** object:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; weirdness = (3 + 5j)</p>@<p>&gt;&gt;&gt; type(weirdness)</p>@<p>&lt;class ‘complex’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>Note that in Python “j” is used for the imaginary component (“i” is@commonly used in physics and math textbooks).<S-CR> Accuracy and Garbage@--------------------<S-CR>Integers can be represented accurately in a computer because they are@nicely discrete. Later versions of Python implement integers in such a@way as they can be arbitrarily long, and don’t have to be explicitly@specified as such.<S-CR>Floating point numbers are only so accurate (the default level of@precision is 28 places). This can become an issue with numbers that@never end, like 1/3, or numbers which are really large. Just for fun,@you can try adding .1 + .1 + .1 to see what happens.<S-CR>A final point: floating point number can contain some “garbage bits” in@the 1/1000000 decimal place and beyond, even if you’ve specified it as@simply as 1.0 – something to be aware of when doing tests of equality.<S-CR> Numeric Types as Methods@------------------------<S-CR>We have seen numeric types like **int** and **float** used to describe@objects, but they can also be used to convert data types (“type@casting”) by invoking them as constructor methods. Here’s how you can@convert an **int** to a **float**:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; one = 1</p>@<p>&gt;&gt;&gt; one_float = float(one)</p>@<p>&gt;&gt;&gt; type(one_float)</p>@<p>&lt;class ‘float’&gt;</p>@<p>&gt;&gt;&gt; and_back = int(one_float)</p>@<p>&gt;&gt;&gt; type(and_back)</p>@<p>&lt;class ‘int’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>Python will even try to convert strings to numeric types. If it can’t,@you’ll get a **ValueError** exception.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; one_string = ("1")</p>@<p>&gt;&gt;&gt; one_string_float = float(one_string)</p>@<p>&gt;&gt;&gt; one_string_float</p>@<p>1.0</p>@<p>&gt;&gt;&gt; type(one_string_float)</p>@<p>&lt;class ‘float’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>You can also directly specify variables invoking the constructor with@appropriate arguments. Python will do its level best to whistle up the@right object for you. Here are some examples:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; complex(1,2) &gt;&gt;&gt; complex(1)</p>@<p>(1+2j) (1+0j</p>@<p>&gt;&gt;&gt; float(1) &gt;&gt;&gt; int(‘333’)</p>@<p>1.0 333</p>@<p>&gt;&gt;&gt; int(1.3) &gt;&gt;&gt; str(123)</p>@<p>1 ‘123’</p></td>@</tr>@</tbody>@</table><S-CR>Getting User Input@------------------<S-CR>Python has built-in method for getting information from the user using@the standard input stream (think “keyboard” for now). You probably won’t@be building applications using direct user input very often, but it’s@handy to know how to use. The syntax is straightforward:<S-CR>input( \<some string\> ) Python produces this dialog possibility:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; answer = input("Hey, Pat, how’s it going? ")</p>@<p>Hey, Pat, how’s it going? <strong>Awesome!</strong></p>@<p>&gt;&gt;&gt; answer</p>@<p>‘Awesome!’</p></td>@</tr>@</tbody>@</table><S-CR>The response will always be returned as a string, no matter what, as you@can see here:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; one = input("Can I pleeese have a one? ")</p>@<p>Can I pleeese have a one? <strong>1</strong></p>@<p>&gt;&gt;&gt; one</p>@<p>‘1’</p>@<p>&gt;&gt;&gt; type(one)</p>@<p>&lt;class ‘str’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>If you need an integer, you’ll have to use the **int** constructor to@type-cast it.<S-CR>You now have the wisdom of the ages at your disposal – a good bit of it,@anyway. Let’s see if you can put some of this to good use.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise:</p>@<p>Use the help facility to learn about the modulo (%) operator, or simply experiment empirically.</p>@<ul>@<li><p>If it takes three buckets of water to put out a campfire (two just won’t do it), how many campfires can you extinguish with 50 buckets? Solve the problem using the modulo operator.</p></li>@<li><p>Create a program that tests how “*”, ‘/’, “+” and “-“ are implemented for string, float, and complex numbers. Use a docstring to document it and make sure it works when calling help on it. Include some comments as a kindness to yourself and your teammates.</p></li>@<li><p>Create a program that asks the user for their name, sign, and favorite beverage, then asks them to confirm that information.</p></li>@</ul></td>@</tr>@</tbody>@</table><S-CR>“String Theory” @---------------<S-CR>Now that you know how to create stings, let’s explore what how we can@manipulate and interact with them.<S-CR>The first thing you should know that strings are **sequences**. We’ll@discuss more complicated sequences later, but for now you should know@you can iterate over them quite easily[6]. Check this out:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; some_string = "Hey!"</p>@<p>&gt;&gt;&gt; for s in some_string:</p>@<p>... print(s)</p>@<p>...</p>@<p>H</p>@<p>e</p>@<p>y</p>@<p>!</p></td>@</tr>@</tbody>@</table><S-CR>Here, we used the **for** statement to loop through each element of the@string. The **for** statement is really simple to implement. The syntax@is:<S-CR>> for \<the name of the index\> in \<some iterable\>:@>@> \<an indented suite\>[7]<S-CR> String Methods@--------------<S-CR>There’s a rich inventory of methods baked into the **str** object that@makes text processing really easy[8]. As with any Python object, we can@get a quick look using **dir**.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dir(str)</p>@<p>[&lt;snip&gt;, ‘capitalize’, ‘casefold’, ‘center’, ‘count’, ‘encode’, ‘endswith’, ‘expandtabs’, ‘find’, ‘format’, ‘format_map’, ‘index’, ‘isalnum’, ‘isalpha’, ‘isdecimal’, ‘isdigit’, ‘isidentifier’, ‘islower’, ‘isnumeric’, ‘isprintable’, ‘isspace’, ‘istitle’, ‘isupper’, ‘join’, ‘ljust’, ‘lower’, ‘lstrip’, ‘maketrans’, ‘partition’, ‘replace’, ‘rfind’, ‘rindex’, ‘rjust’, ‘rpartition’, ‘rsplit’, ‘rstrip’, ‘split’, ‘splitlines’, ‘startswith’, ‘strip’, ‘swapcase’, ‘title’, ‘translate’, ‘upper’, ‘zfill’]</p></td>@</tr>@</tbody>@</table><S-CR>Most of these are self-explanatory, but we’ll discuss a few of the most@commonly-encountered ones and how to use them here. You can test a@string – or a bit of one – to see what type of characters are in it.@Note that in Python there is no “character” object *per se* – a single@character is simply a really short string. We could apply these@operations to the intact some\_string object just as easily.<S-CR>Also note that when we execute a method, we need the parentheses even if@we’re not supplying any arguments[9]. The following script demonstrates@some of the string methods and introduces the use of “{ }”. These serve@as placeholders for arguments supplied to the **format** method. We’ll@cover formatting in more detail later.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_strings.py</p>@<p>some_string = "$R5a "</p>@<p>for s in some_string:</p>@<p>print("&gt;{}&lt; is alphanumeric? {}.”.format(s, s.isalnum()))</p>@<p>print("&gt;{}&lt; is alpha? {}.”.format(s, s.isalpha()))</p>@<p>print("&gt;{}&lt; is numeric? {}.”.format(s, s.isnumeric()))</p>@<p>print("&gt;{}&lt; is upper? {}.”.format(s, s.isupper()))</p></td>@</tr>@</tbody>@</table><S-CR>This provides basic information about each character:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;$&lt; is alphanumeric? False</p>@<p>&gt;$&lt; is alpha? False</p>@<p>&gt;$&lt; is numeric? False</p>@<p>&gt;$&lt; is upper? False</p>@<p>&gt;R&lt; is alphanumeric? True</p>@<p>&gt;R&lt; is alpha? True</p>@<p>&gt;R&lt; is numeric? False</p>@<p>&gt;R&lt; is upper? True</p>@<p>&lt;snip&gt;</p></td>@</tr>@</tbody>@</table><S-CR>There are lots of methods to query for, and change the case of, a@string. Note that the queries return a Boolean (**True** or **False**)@object.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_cubs.py</p>@<p>my_team = "The Chicago Cubs"</p>@<p>print("my team ends with an ‘s’? {} \ #\ continues the line</p>@<p>.”format(my_team.endswith("s")))</p>@<p>print("my team starts with an ‘s’? {} \</p>@<p>.”format(my_team.startswith("s")))</p>@<p>print("in caps {} .” \</p>@<p>.format(my_team.upper()))</p>@<p>print("swapped-case {} .” \</p>@<p>.format(my_team.swapcase()))</p></td>@</tr>@</tbody>@</table><S-CR>And here are the results:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>my team ends with an ‘s’? True</p>@<p>my team starts with an ‘s’? False</p>@<p>in caps THE CHICAGO CUBS</p>@<p>swapped-case tHE cHICAGO cUBS</p></td>@</tr>@</tbody>@</table><S-CR> Breaking up and Getting Together Again@--------------------------------------<S-CR>There are also methods to split up strings (returning a **list**[10]@object) and to create a string by stitching together the elements of an@**iterable**[11] object. In the example below, we can supply the@**split** method a single argument – the string we’ll use to determine@where to break the main string up[12]. Providing a single space (or@calling it with no arguments) splits up the words into individual@**list** elements.<S-CR>The reciprocal operation is **join**. With **join** we provide a string@to insert between each element pulled from the list to reform the@string. Though this example uses a **list**, this method works for any@iterable object (such as a **tuple**[13] or even another string).<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_misc_strings.py</p>@<p>my_team = "The Chicago Cubs"</p>@<p>split_team = my_team.split(" ")</p>@<p>print("splits: {}”.format(split_team))</p>@<p>join_string = "!!!"</p>@<p>together_again = join_string.join(split_team)</p>@<p>print("together again: {}.” \</p>@<p>.format( together_again), end = join_string+"\n")</p>@<p>#results:</p>@<p>splits: [‘The’, ‘Chicago’, ‘Cubs’]</p>@<p>together again: The!!!Chicago!!!Cubs.!!!</p></td>@</tr>@</tbody>@</table><S-CR> Literals and Escape Sequences@-----------------------------<S-CR>Sometimes, you need to insert a specific character into a string that@you can’t type directly. There are a couple ways to handle this.<S-CR>The first is using “escape sequences.” We’ve already seen that “\\n”@produces a new line character, but there are many more. The idea here is@that inclusion of a backslash “\\” tells the interpreter to do something@special with (“escape”) the character that follows instead of taking it@literally. Others include:<S-CR>> \\t tab@>@> \\r carriage return@>@> \\’ prints a single quote@>@> \\” prints a double quote@>@> \\\\ if you really want a backslash<S-CR>Another way to handle this is to figure out what the character code is.@You can do that easily enough for the first 128 (ASCII) characters by@printing them out with the **chr** method[14], finding your character,@then using the same method in your code . You could go something like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_ord_chars.py</p>@<p>for i in range(33, 36): #yes, I’m cheating I know it’s 34</p>@<p>print (i, chr(i))</p>@<p>QUOTE = chr(34)</p>@<p>print("I’m a double quote: {}.”.format(QUOTE))</p></td>@</tr>@</tbody>@</table><S-CR>… to produce this result:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>33 !</p>@<p>34 "</p>@<p>35 #</p>@<p>I’m a double quote: "</p></td>@</tr>@</tbody>@</table><S-CR>Cleaning House and Moving Furniture@-----------------------------------<S-CR>Python’s string methods have an easy-to-use, and remarkably efficient,@ways to do searches and replacements. “Under the hood” they wrap regular@expressions (“regexes”) and, for many operations, deliver the same@performance. Once we get into regexes later, you will really appreciate@this implementation.<S-CR>Please study the sample code in py\_string\_manipulation.py – it@demonstrates the **find**, **replace,** and **strip** methods,@introduces the keywords **in** and **not**, and demonstrates the use of@the **len** built-in method.<S-CR>Keep your eye out for the keyword **in** which returns a Boolean object@– **True** if the iterable contains the object tested for, **False**@otherwise. The keyword **not** can be used more generally and serves as@the Boolean negation operator (flips the evaluation).<S-CR>Also observe how Python handles Boolean tests applied to things like@strings. You might think this is pretty weird:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dog = “Quinn the Husky”</p>@<p>&gt;&gt;&gt; dog</p>@<p>‘Quinn the Husky’</p>@<p>&gt;&gt;&gt; not dog</p>@<p>False</p></td>@</tr>@</tbody>@</table><S-CR>Huh? How can Python possibly evaluate a string as a Boolean value? Well,@it turns out that whenever we ask for a Boolean evaluation, Python will@go ahead and serve one up. It will return **False** if the object is the@number 0, the keyword **None**[15], a null string, an empty list, or any@other empty object. The opposite is also the case. When a Boolean@operation is applied against a non-zero number, a string with at least@one character, etc., **True** will be returned. Here’s how one might use@this behavior to test whether a user provided any input:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dog = input(“What’s your dog’s name? &gt; ”)</p>@<p>&gt;&gt;&gt; What’s your dog’s name? &gt; Quinn</p>@<p>&gt;&gt;&gt; if dog:</p>@<p>print(dog)</p>@<p>Quinn</p></td>@</tr>@</tbody>@</table><S-CR>Note the use of the **if** keyword for a simple logical branch. The@syntax is straightforward:<S-CR>**if** \<condition\>:<S-CR>\<an indented suite\><S-CR>Let’s take a tour of some of the methods built into the string object@with some real code. Here we’ll learn ways to find and replace@components of **str** objects. We’ll begin with a string containing some@popular sins.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_string_manipulation.py</p>@<p>seven_deadly = " avarice envy wrath sloth \</p>@<p>gluttony lust hubris "</p></td>@</tr>@</tbody>@</table><S-CR>Here is how we can use the keyword **in**[16] to figure out if one@string can be found within another. This is a very vague query that will@yield a Boolean response. In Python we can use **not** in a logical@expression for negation.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#Do we have this sin? Note the use of lower()</p>@<p>&gt;&gt;&gt; sin = ‘eNvY’</p>@<p>&gt;&gt;&gt; print("{} in there? {}\n”\</p>@<p>.format(sin.lower(), \</p>@<p>sin.lower() in seven_deadly.lower()))</p>@<p>envy in there? True</p>@<p>#doesn’t exist (use not for Boolean negation)?</p>@<p>&gt;&gt;&gt; print("try the key word not")</p>@<p>&gt;&gt;&gt; print("{} NOT in there? {}\n” \</p>@<p>.format(sin.lower(), \</p>@<p>sin.lower() not in seven_deadly\</p>@<p>))</p></td>@</tr>@</tbody>@</table><S-CR>Note that we’re invoking the lower method when searching the string.@It’s not necessary, but not a bad idea because it lets you get away@without trying every petty permutation of the word.<S-CR>A more surgical approach is to use **find**. This will attempt to locate@the initial position of the string you’re looking for and return its@findings. If it strikes out, **find** will return a -1.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#Locate the position. Note the two-element tuple object.</p>@<p>&gt;&gt;&gt; for sin in (‘envy’, ‘texting while driving’):</p>@<p>sin_position = seven_deadly.find(sin.lower())</p>@<p>if sin_position &gt; = 0:</p>@<p>print("Yup. We found ‘{}’ \</p>@<p>starting in position {}\n.” \</p>@<p>.format(sin.lower(), sin_position))</p>@<p>else:</p>@<p>print("Nope. Since find() returned {}, \</p>@<p>‘{}’ wasn’t there\n.” \</p>@<p>.format( sin_position, sin.lower()))</p>@<p>Yup. We found 'envy' starting in position 9</p>@<p>Nope. Since find() returned -1, no 'texting while driving'</p></td>@</tr>@</tbody>@</table><S-CR>It’s possible to replace characters with new ones with the – you guessed@it – **replace** method[17]. Here’s a simple example that shows a@potential pitfall for a new Python programmer. Strings are “immutable” –@not changeable. Running a replace operation doesn’t change the string.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#Replace characters</p>@<p>&gt;&gt;&gt; print("strings are immutable - compare these")</p>@<p>&gt;&gt;&gt; seven_deadly.replace(‘avarice’, ‘greed’)</p>@<p>&gt;&gt;&gt; print("no replacement: ", seven_deadly)</p>@<p>no replacement: avarice envy wrath sloth gluttony lust hubris</p>@<p>&gt;&gt;&gt; seven_deadly = seven_deadly.replace(‘avarice’, ‘greed’)</p>@<p>&gt;&gt;&gt; print("replaced at last: ", seven_deadly + ‘\n’)</p>@<p>replaced at last: avarice envy wrath sloth gluttony lust hubris</p></td>@</tr>@</tbody>@</table><S-CR>You can remove leading and trailing whitespaces using various flavors of@the **strip** method[18]. This is really handy when handling@potentially-messy data like user inputs. The following example@demonstrates this, along with one of Python’s top-level functions len.@Note that **len** is not built into the string method – it’s generally@available for all objects.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#Remove leading/trailing spaces. Note chained methods.</p>@<p>&gt;&gt;&gt; print("original sin list is {} characters long".</p>@<p>format(len(seven_deadly)))</p>@<p>original sin list is 66 characters long</p>@<p>&gt;&gt;&gt; print("with the white spaces removed it's {} long".</p>@<p>format(len(seven_deadly.strip())))</p>@<p>with the white spaces removed it's 60 long</p></td>@</tr>@</tbody>@</table><S-CR>Python’s ability to have one function “swallow” the output of another so@it’s possible to chain operations together. Here, the output from the@**strip** method is fed into the **len** method. The combined result is@fed to **format**. And the result of all that activity is rolled up into@a single argument to **print**. You’ll see a lot of code like this as@you explore Python.<S-CR> Making Things Beautiful: the Format Mini-Language[19]@-----------------------------------------------------<S-CR>You have already seen some basic applications of Python’s text@formatting capabilities. If you place opposing curly braces in a string@they serve as “catcher’s mitt” for any arguments you provide to@**format**:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_format.py</p>@<p>#Basic usage</p>@<p>&gt;&gt;&gt; stg = "{} {}".format("Hey","Joe")</p>@<p>&gt;&gt;&gt; print(stg)</p>@<p>Hey Joe</p></td>@</tr>@</tbody>@</table><S-CR>Generally, you want to supply at least as many arguments as there are@curly brace pairs, but other than that you can provide just about any@kind of an object[20]. You can go upmarket with these in lots of ways.@For instance, you can “tag” the fields with index values. These both@work:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#numbered fields ('all or none' here)</p>@<p>&gt;&gt;&gt; stg = "{0} {1} {2}".format("George", "Paul", "John")</p>@<p>&gt;&gt;&gt; print(stg)</p>@<p>“George Paul John”</p>@<p>&gt;&gt;&gt; stg = "{2} {1} {0}".format("George", "Paul", "John")</p>@<p>&gt;&gt;&gt; print(stg)</p>@<p>“John Paul George”</p></td>@</tr>@</tbody>@</table><S-CR>One don’t even need to use all the arguments provided, and can reuse any@of them. You might experiment. Another way to “tag” the fields is to use@names. This can make your code extremely readable and transparent – even@if the format string and **print** function happen to be separated by@several pages of code.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#named fields ('all or none'; note no quotes around names)</p>@<p>&gt;&gt;&gt; stg = """\</p>@<p>Dear {donor},</p>@<p>I'm running for {office} and would like to shake</p>@<p>you down for a ${dollars} contribution.</p>@<p>Sincerly,</p>@<p>- {candidate}"""</p>@<p>&gt;&gt;&gt; print(stg.format(donor = "SuperPAC", office = "President",</p>@<p>dollars =100, candidate = 'Pat'))</p>@<p>Dear SuperPAC,</p>@<p>I'm running for President and would like to shake</p>@<p>you down for a $100 contribution.</p>@<p>Sincerly,</p>@<p>Pat</p></td>@</tr>@</tbody>@</table><S-CR>Note that the items provided, like donor and office, are not quoted.@They actually become names in Python’s namespace that become associated@with the values like “SuperPAC” and “President”.<S-CR>It’s also easy to provide column width and justification specifications.@The general form of the specification is something like:<S-CR>{ \<field name\> : \<alignment\>[21] \<width\> }<S-CR>This example creates three columns of equal width, left justified in a@format string, then “recycles” the string to build a nicely-formatted@table.<S-CR><table>@<tbody>@<tr class="odd">@<td><p># This bit of code run in a script…</p>@<p>stg = "{0:&lt;10} {1:&lt;10} {1:&lt;10}"</p>@<p>print(stg.format("Presenting: Addition!!!", ''))</p>@<p>print(stg.format("output", "input"))</p>@<p>print(stg.format("=" * 6, "=" * 6))</p>@<p>print(stg.format(4, 2))</p>@<p>print(stg.format(8, 4))</p>@<p># …yields the following</p>@<p>Presenting: Addition!!!</p>@<p>output input input</p>@<p>====== ====== ======</p>@<p>4 2 2</p>@<p>8 4 4</p></td>@</tr>@</tbody>@</table><S-CR>A couple nuances are worth noting. The formatting string uses only two@index values: 0 and 1. That means it only needs two input arguments even@though there are three fields.<S-CR>You can also ask Python to temporarily cast variables into other forms@for the purposes of output. Here, we’re printing out decimal, binary,@and hex flavors of some numbers.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; fmt = "{0:&gt;6} = {0:&gt;#16b} = {0:#06x}"</p>@<p>&gt;&gt;&gt; for i in 1, 23, 456, 7890:</p>@<p>print(fmt.format(i))</p>@<p>1 = 0b1 = 0x0001</p>@<p>23 = 0b10111 = 0x0017</p>@<p>456 = 0b111001000 = 0x01c8</p>@<p>7890 = 0b1111011010010 = 0x1ed2</p></td>@</tr>@</tbody>@</table><S-CR>Other options allow you to do things like represent add “+” and “-“@signs in front of values, to pad out columns, etc. Things can be much@more complicated but Python’s official documentation is (fortunately)@exceptional on this topic[22].<S-CR>Here’s one might apply combined format options on a small database of@people in a study. Here, were applying numeric labels, justification,@column width and numeric types – all in a succinct format string. You’ll@note that we’re making a **list** of **tuples** (more on both these@later), we’re unpacking[23] the **tuples**, then printing them in table@format.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_format_1.py</p>@<p>"""List people’s names, ages and weights."""</p>@<p>data = [</p>@<p>("Steve", 59, 202),</p>@<p>("Dorothy", 49, 156),</p>@<p>("Simon", 39, 155),</p>@<p>("David", 61, 135) ]</p>@<p>for name, age, weight in data:</p>@<p>print("{0:&lt;12s} {1:4d} {2:4d}.” \</p>@<p>.format(name, age, weight))</p></td>@</tr>@</tbody>@</table><S-CR>OK. You have learned a lot about string and numeric data types, how to@work with strings, and how to make nicely formatted output. Now, let’s@flex some Pythonic muscles and make something beautiful!<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise:</p>@<ul>@<li><p>Please write an application that quizzes challenges the user to guess all of Python’s keywords, keeping track of the successes. When the user gives up (maybe by typing “help”), report the number of correctly-guessed keywords, then number not guessed, and a nicely-formatted table for each group.</p></li>@<li><p>Hint: you’ll find some useful tools in the keyword library, which you can get by going:</p></li>@</ul>@<blockquote>@<p>import keyword</p>@</blockquote>@<p>Hint: you just might find the <strong>in</strong> keyword useful to determine membership in keywords.</p>@<p>Also, you’ll need to be able to use the <strong>for</strong> and <strong>if</strong> statements. Recall the general forms:</p>@<p>for i in iterable_object: if condition:</p>@<p>indented suite runs each loop indented suite runs if condition is True</p>@<p>*conditions can be complex e.g., A and B</p>@<p>… and if you need to test for equality, you can use the == operator like this:</p>@<p>&gt;&gt;&gt; 1 == 1</p>@<p>True</p></td>@</tr>@</tbody>@</table><S-CR>Language Components@===================<S-CR>From a syntax perspective, Python is a simple language. As we’ve seen,@there are only 33 keywords. While Python has data types, variables don’t@need to be declared to be of some specific type before use. There’s no@requirement to initialize variables. Objects generally come to us@“batteries included.” Pretty slick, no?<S-CR>Indentation@-----------<S-CR>We’ve seen the **for** statement before, but let’s take another look.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; myrange = range(2)<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>@<p>&gt;&gt;&gt; for value in myrange:</p>@<p>... print(value)</p>@<p>0</p>@<p>1</p></td>@</tr>@</tbody>@</table>@<section class="footnotes" role="doc-endnotes">@<hr />@<ol>@<li id="fn1" role="doc-endnote"><p>The <strong>range</strong> object is one of many Python objects that’s “lazily evaluated”. That means it merely has the <span class="underline">capability</span> to produce. It will not do so until asked. These two objects take about the same (small) amount of memory:</p>@<p>&gt;&gt;&gt; range(2)</p>@<p>range(0, 2)</p>@<p>&gt;&gt;&gt; range(2000000000000000000000)</p>@<p>range(0, 2000000000000000000000)</p>@<p>These will make sequences of integers starting at 0 and ending one shy of the provided end point. More on how to specify ranges later.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>@</ol>@</section><S-CR>The first line is of the form:<S-CR>\<key word\> \<name for index\> **in** \<iterable object\>:<S-CR>That’s it – no fussing around with pointers, instancing index values, or@running past the end of the object. The **for** statement “just works.”<S-CR>What follows is an “indented suite”, and it can comprise any number of@lines of code. Indentation is extremely important in Python because@that’s how the interpreter keeps track of how to group statements.@Unlike languages such as C and Java, it can’t rely on braces for that@purpose – Python uses <span class="underline">only</span> indentation.@Statements at the same level of indentation are treated as a being in@the same code block, and code blocks can be nested to any level.<S-CR>This further simplifies Python – it’s unburdened by the clutter of@braces, statement terminating semicolons, and loop terminating keywords.@All this creates and enforces a high level of readability. The cost, of@course, is the need to have attention to fine level of detail and a@limited ability to write spatially-dense code.<S-CR>Strictly speaking, Python doesn’t care how much each statement in the@same suite is indented, as long as all are the same. Some developers use@tabs (each is seen by the interpreter as a single character), but four@white spaces is the recommended convention per Python’s official style@guide “PEP-8.” PEP-8 is a bit of a dry read, but well worth a quick@look, especially if you’re planning to work as part of a team[24].<S-CR>The if Statement@----------------<S-CR>We’ve touched on the **if** statement, the most basic of control@statements. Let’s expand the discussion a bit. Its general form is:<S-CR>if \<condition\>:<S-CR>\<indented suite\><S-CR>elif \<condition\>:<S-CR>\<indented suite\><S-CR>…<S-CR>else:<S-CR>\<indented suite\><S-CR>The first condition presented to the **if** is evaluated True or False.@If evaluated **True**, the indented suite immediately beneath is@executed and it’s done. Execution drops out of the entire block of code.<S-CR>There can be any number of **elif** (“else if”) statements and they are@evaluated in top-to-bottom order. If any is **True**, the associated@indented suite of statement is evaluated and it’s done. Only when no@**if** or **elif** condition is met will the **else** suite be@executed[25].<S-CR>A couple notes of potential interest:<S-CR>The **elif** and **else** clauses are completely optional, and leaving@them off is routine. Here, we perform an operation that only makes sense@of we have user input. The **strip** operation will not be attempted@otherwise.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>if user_input:</p>@<p>user_input.strip()</p></td>@</tr>@</tbody>@</table><S-CR>If the denominator is zero, the compiler won’t go on to attempt the@impossible and you won’t experience a crash due to a@**ZeroDivisionError**.<S-CR>.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>if denominator:</p>@<p>print(numerator/denominator)</p></td>@</tr>@</tbody>@</table><S-CR>Here’s a program to demonstrate a more complicated application. When@this for statement executes, it iterates over the elements of a@tuple-of-tuples object. The first time it picks off the tuple (1, 0) and@the second time it grabs (9, 3). Here’s the twist: each time through, it@assigns the name numerator to the first element of the tuple; and the@name denominator to the second element.<S-CR>If you have a compound evaluation, the conditions are evaluated left to@right. As soon as the interpreter knows whether the condition is@**True** or **False**, it’s done. You can use this to your advantage to@check for unsafe conditions. For instance, you might go:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_compound_conditionals.py</p>@<p>for numerator, denominator in ( (1, 0), (9, 3) ):</p>@<p>if denominator and numerator/denominator == 3:</p>@<p>print("yay! We have a {}!"\</p>@<p>.format(numerator/denominator))</p></td>@</tr>@</tbody>@</table><S-CR>The result, as expected, shows only results only for the valid input:<S-CR>|                     |@|---------------------|@| yay! We have a 3.0! |<S-CR>The while Statement@-------------------<S-CR>The **while** statement is also pretty straightforward:<S-CR>while \<condition\>:<S-CR>\<indented suite\><S-CR>else:<S-CR>\<indented suite\><S-CR>The indented suite will be executed top-to-bottom forever until it’s@asked to stop or the condition is no longer **True**. Here’s a simple@example using a condition to halt execution. Note that the “sentinel@condition” and counter are defined outside and before the loop[26].<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_while.py</p>@<p>stop_me = False</p>@<p>counter = 0</p>@<p>while not stop_me:</p>@<p>print("The counter is now: {}.”.format(counter))</p>@<p>if counter&gt;1:</p>@<p>stop_me = True</p>@<p>counter = counter+1 #counter + = 1</p>@<p>else:</p>@<p>print("Yo. I’m done!")</p></td>@</tr>@</tbody>@</table><S-CR>This works pretty well, as evidenced by its output.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>The counter is now: 0.</p>@<p>The counter is now: 1.</p>@<p>The counter is now: 2.</p>@<p>Yo. I’m done!</p></td>@</tr>@</tbody>@</table><S-CR>There are more elegant ways to proceed, however. A common idiom is to@use the keyword **break** within the loop to terminate it immediately.@This can be combined with tautologically-true condition to streamline@things. For instance, you could go:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_while_1.py</p>@<p>counter = 0</p>@<p>while True:</p>@<p>print("The counter is now: {}.”.format(counter))</p>@<p>if counter&gt;1:</p>@<p>break</p>@<p>counter + = 1</p>@<p>else:</p>@<p>print("Yo. I’m done!")</p></td>@</tr>@</tbody>@</table><S-CR>Not only is this simple to read, it doesn’t require much in the way of@resources to evaluate. This is not at issue with a simple application,@but if your project involves millions of iterations e.g., a polling@routine for a web server, efficiency becomes relevant.<S-CR>You probably noticed that the **else** clause did not execute. The@reason is that its indented suite runs only if the **while** statement@terminates due to the condition becoming **False**. The **break**@keyword causes the code that would do this to be bypassed.<S-CR>The philotic twin of the **break** statement is **continue**. When@**continue** is encountered, execution is immediately passed to the top@of the loop where the condition is reevaluated.<S-CR>The **else** clause is completely optional. Since we’re using **break**,@we’ll get rid of the extra baggage and show how **continue** might be@applied. Note the use of the comparative operator == (returns a Boolean@evaluation of whether the two values are the same) and the shortcut way@to increment the counter with the += operator[27].<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_while_2.py</p>@<p>counter = 0</p>@<p>while True:</p>@<p>if counter == 1:</p>@<p>print("One is the loneliest number \</p>@<p>that there ever was.")</p>@<p>counter += 1</p>@<p>continue</p>@<p>print("The counter is now: {}.”.format(counter))</p>@<p>if counter&gt;1:</p>@<p>break</p>@<p>counter += 1</p></td>@</tr>@</tbody>@</table><S-CR>The preceding program produces this output:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>The counter is now: 0.</p>@<p>One is the loneliest number that there ever was.</p>@<p>The counter is now: 2.</p></td>@</tr>@</tbody>@</table><S-CR>Inner and Outer Loops@---------------------<S-CR>The final point I would make here is that **break** and **continue**@work on both **for** and **while** loops. And both work only on the@inner-most loop (the one they reside inside of). Here’s an example of a@program with both types of loops:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_while_for.py</p>@<p>stop_me = False</p>@<p>counter = 0</p>@<p>for i in range(10):</p>@<p>if i%2: #odd numbers evaluate True:</p>@<p>while True:</p>@<p>if counter = = 1:</p>@<p>print("One is the loneliest \</p>@<p>number that there ever was.")</p>@<p>counter + = 1</p>@<p>continue</p>@<p>print("the counter is now: {} \</p>@<p>and i is now {}.".format(counter, i))</p>@<p>if counter&gt;1:</p>@<p>break #breaks out of the inner(while) loop</p>@<p>counter+ = 1</p>@<p>if i &gt; 5:</p>@<p>print("I’m done - about to go on a break.")</p>@<p>break #this breaks out of the outer (for) loop</p></td>@</tr>@</tbody>@</table><S-CR>It produces this output:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>The counter is now: 0 and i is now 1.</p>@<p>One is the loneliest number that there ever was.</p>@<p>The counter is now: 2 and i is now 1.</p>@<p>The counter is now: 2 and i is now 3.</p>@<p>The counter is now: 2 and i is now 5.</p>@<p>I’m done - about to go on a break.</p></td>@</tr>@</tbody>@</table><S-CR>Some Useful Logical and Binary Operators@----------------------------------------<S-CR>Python comes with a typical set of comparative operators. Here’s a quick@summary:<S-CR>| ==  | Equal to              |@|-----|-----------------------|@| !=  | Not equal             |@| \<  | Less than             |@| \>  | Greater than          |@| \<= | Less than or equal    |@| \>= | Greater than or equal |<S-CR>There is also a set of bitwise operators. These operate on the 1s and 0s@in a number represented in binary format. You can create a binary@representation of a number in Python by using the keyword **bin**,@something like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; bin(128)</p>@<p>‘0b10000000’</p></td>@</tr>@</tbody>@</table><S-CR>You can see that the result’s first two characters are ‘0b’, flagging it@as a binary representation. You’ll also note that the result is a@string, which you can’t do much with mathematically – you need to do@operations <span class="underline">before</span> it’s converted.<S-CR>The operators for bitwise shifts are **\>\>** and **\<\<** and here’s@how you might apply them as you’re creating the binary number. These are@like changing the power of 10 to which you raise a base 10 number.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_binary_operations.py</p>@<p>mybin_1000 = bin(1000)</p>@<p>fmt = "{:30} {:&lt;30}"</p>@<p>print("Base 2 operations:")</p>@<p>print(fmt.format("mybin_1000: ", mybin_1000))</p>@<p>print(fmt.format("mybin_1000 shifted left: ", bin(1000 &lt;&lt; 3)))</p>@<p>print(fmt.format("mybin_1000 shifted right: ", bin(1000 &gt;&gt; 5)))</p></td>@</tr>@</tbody>@</table><S-CR>The output shows the result of a left shift is to pad the original with@0s to the right, and the right shift effectively truncates it[28].<S-CR><table>@<tbody>@<tr class="odd">@<td><p>mybin_1000: 0b1111101000</p>@<p>mybin_1000 shifted left: 0b1111101000000</p>@<p>mybin_1000 shifted right: 0b11111</p></td>@</tr>@</tbody>@</table><S-CR>There are other operators you can use to “mask” a binary number with@another. A common use is IP address masking when setting up subnets.@These are:<S-CR>| a & b  | Both 1 -\> 1, otherwise -\>0                                        |@|--------|---------------------------------------------------------------------|@| a \| b | Both 0 -\> 0, otherwise -\>1                                        |@| \~a    | “flips” each bit. 1 -\> 0 and 0 -\>1                                |@| a ^ b  | if the bit in b is 0, use the bit in a; otherwise flip the bit in a |<S-CR>This is just an aside, but you can use the "exclusive or", a.k.a. XOR,@implemented with the "^" operator, as a cheesy encryption tool. That's@because sequential applications simply flip the results. The first@application encrypts the original and the second application undoes the@encryption. Just for fun, file "**py\_magic\_decoder\_ring.py"** has an@example.<S-CR><table>@<tbody>@<tr class="odd">@<td><blockquote>@<p>Exercise:</p>@</blockquote>@<ul>@<li><p>Create a program that asks the user to guess a number between 1 and 100 (whole numbers only). If the guess is wrong, let the user know if the guess is too high or too low. If the guess is right, offer hearty congratulations and exit the program. If, after five attempts, the user can’t get the number then offer deep condolences and invite him/her to try again. Be sure to check for valid input and remind the user if necessary.</p></li>@<li><p>Hint: the random library has several handy pseudo-random number generator functions such as <strong>random.randrange()</strong>. You’ll need to import random in order to use it. A good way to start might be:</p></li>@</ul>@<blockquote>@<p><strong>&gt;&gt;&gt; import random</strong></p>@<p><strong>&gt;&gt;&gt; help(random)</strong></p>@</blockquote>@<ul>@<li><p>Also, you might consider putting in some sort of logical that will “freeze” both the random number and the user’s guess while debugging. That gives you a stationary target.</p></li>@</ul></td>@</tr>@</tbody>@</table><S-CR>Collections@===========<S-CR>Next, we’ll investigate several of the built-in Python **sequences.**@Sequences are composite objects (that is they contain zero or more@separate objects). Sequence objects are aware of their status as such@and have built-in methods to take advantage of that fact. For instance,@all sequences are **iterators** (they know how to loop over themselves),@they know how long they are, and can be indexed.<S-CR>Creating Sequences @------------------<S-CR>In the code below, we will take a first-order look at several sequences,@and how one might form them. Note that we can use data types such as@**range** and **list** as methods to create new instances of said data@types.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_sequence_survey.py</p>@<p>the_string = "strings are sequences with an encoding"</p>@<p>the_bytes = bytearray(the_string, encoding = ‘UTF-8’)</p>@<p>the_range = range(10)</p>@<p>the_list = list(range(10))</p>@<p>the_tuple = tuple(range(10))</p>@<p>print("String: ", the_string)</p>@<p>print("Bytes: ", the_bytes)</p>@<p>print("List: ", the_list)</p>@<p>print("Tuple: ", the_tuple)</p></td>@</tr>@</tbody>@</table><S-CR>When you execute this code, you’ll get output something like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>String : strings are sequences with an encoding</p>@<p>Bytes<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> : bytearray(b’strings are sequences</p>@<p>with an encoding’)</p>@<p>List : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>@<p>Tuple : (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</p></td>@</tr>@</tbody>@</table>@<section class="footnotes" role="doc-endnotes">@<hr />@<ol>@<li id="fn1" role="doc-endnote"><p>Note that the <strong>bytearray’s</strong> string representation is proceeded by a “b”. That’s just a visual indicator that the object is stored as bytes. Other annotations you might encounter include :</p>@<p>u (Unicode, in Python 2.x) r (asks Python to interpret \n \t, and other format characters literally)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>@</ol>@</section><S-CR>As is the case with strings, it’s possible to create several objects@directly using the appropriate braces. This approach is called "duck@typing" – from the interpreter's perspective, if it walks like a duck@and quacks like a duck, it must be a duck. These all work:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; another_list</p>@<p>["what’s", ‘up’, ‘doc?’]</p>@<p>&gt;&gt;&gt; type(another_list)</p>@<p>&lt;class ‘list’&gt;</p>@<p>&gt;&gt;&gt; a_dict = {‘a’:’eh’, ‘b’:’bee’, ‘c’:’see’}</p>@<p>&gt;&gt;&gt; a_dict</p>@<p>{‘a’: ‘eh’, ‘c’: ‘see’, ‘b’: ‘bee’}</p>@<p>&gt;&gt;&gt; type(a_dict)</p>@<p>&lt;class ‘dict’&gt;</p>@<p>&gt;&gt;&gt; my_tuple = (1,3,4)</p>@<p>&gt;&gt;&gt; my_tuple</p>@<p>(1, 3, 4)</p>@<p>&gt;&gt;&gt; type(my_tuple)</p>@<p>&lt;class ‘tuple’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>Naturally, any of objects can be directly created with a constructor@(using the object name as a verb). This can take the guess work out of@the situation. Here’s an example for the **set**[29] object:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; favorite_set = set()</p>@<p>&gt;&gt;&gt; type(favorite_set)</p>@<p>&lt;class ‘set’&gt;</p>@<p>&gt;&gt;&gt; favorite_set.add(1)</p>@<p>&gt;&gt;&gt; favorite_set</p>@<p>{1}</p></td>@</tr>@</tbody>@</table><S-CR>Python is not strongly typed (at first, anyway). Unlike many languages,@Python does not enforce variable declaration and homogenous types within@a collection structure. In fact, it’s very cavalier about use and reuse@of variable names[30].<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; reusable = "green"</p>@<p>&gt;&gt;&gt; reusable = 1</p>@<p>&gt;&gt;&gt; reusable = ["some", "list", "of", 4, "elements"]</p>@<p>&gt;&gt;&gt; reusable</p>@<p>[‘some’, ‘list’, ‘of’, 4, ‘elements’]</p>@<p>&gt;&gt;&gt; reusable = None</p>@<p>&gt;&gt;&gt; reusable<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>@<p>&gt;&gt;&gt;# (no answer means the value is None)</p></td>@</tr>@</tbody>@</table>@<section class="footnotes" role="doc-endnotes">@<hr />@<ol>@<li id="fn1" role="doc-endnote"><p>The <strong>None</strong> object doesn’t return anything if asked to represent itself. If you need to check, you can go:</p>@<p>&gt;&gt;&gt; a = None</p>@<p>&gt;&gt;&gt; a is None</p>@<p>True<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>@</ol>@</section><S-CR>Creating Index Values with enumerate@------------------------------------<S-CR>Although you don’t need to create index values for your loop, you can@get some easily by using the built-in **enumerate** method. Here’s how@you might apply it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_enumerate_1.py</p>@<p>fruits = (‘apple’, ‘banana’, ‘kiwi’)</p>@<p>for snack_and_index in enumerate(fruits):</p>@<p>print(snack_and_index)</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>#output</p>@<p>(0, ‘apple’)</p>@<p>(1, ‘banana’)</p>@<p>(2, ‘kiwi’)</p></td>@</tr>@</tbody>@</table><S-CR>Here, we created a tuple of fruits. Within the **for** statement we@applied **enumerate**. For each element of the tuple, **enumerate@(**returned a **tuple** of (index, element\_value) ).<S-CR>We can upgrade this a bit by applying some print formatting and by@“unpacking” the **tuple** returned. Here’s how might work:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>py_enumerate_2.py</p>@<p>fruits = ("apple", "banana", "kiwi")</p>@<p>start_at = 1</p>@<p>for index, snack in enumerate(fruits, start_at):</p>@<p>print("fruit #{} is a(n) {}".format(index, snack))</p></td>@</tr>@</tbody>@</table><S-CR>Here are the results:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>fruit #1 is a(n) apple</p>@<p>fruit #2 is a(n) banana</p>@<p>fruit #3 is a(n) kiwi</p></td>@</tr>@</tbody>@</table><S-CR>The names “snack” and “index” have been successively associated with@values contained within the **tuples** provided by **enumerate**, and@are available within the indented suite. You can see that the names are@“recycled” at each iteration. We provided an optional argument@“start\_at” to select the first value of the index produced. If you@don’t provide the argument, the first index value will be zero.<S-CR>Slices and Sequence Indexing@----------------------------<S-CR>So far, we have looked at really small, manageable sequences where it’s@easy and cheap enough to iterate through all the elements. However, in@real-life situations we’re likely to encounter structures that contain@millions of elements. If we have some *a priori* knowledge of where the@element we’re looking for lives, or if we want to apply something better@than a brute-force search algorithm, we would want a more clever way to@approach sequences.<S-CR>Fortunately, Python supports the ability to “slice” a sequence using@index values. For instance, you can go:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; the_list = list(range(0,10))</p>@<p>&gt;&gt;&gt; the_list</p>@<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p>@<p>&gt;&gt;&gt; the_list[0:6:2] # end at 6, stride = 2 grabs every other value</p>@<p>[0, 2, 4]</p></td>@</tr>@</tbody>@</table><S-CR>The general syntax is<S-CR>\<iterable\>\[ \<start\> : \<stop\> : \<stride\> \]<S-CR>The start, stop, and stride parameters are all optional. Be default@start is the first element of the sequence, stop is the last element,@and stride is 1. In the simplest form, the entire sequence will be@produced:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; the_list[:] # [::] works the same</p>@<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p></td>@</tr>@</tbody>@</table><S-CR>Let’s go back and look at the first slicing example. One might expect@that the last element produced would be 6 – after all, isn’t that what@we requested with the stop parameter? Not so – the last element produced@is the one <span class="underline">before</span> the stop parameter …@something to keep in mind to avoid surprises[31].<S-CR>Python also has a built-in **slice** object, which works just like the@index specifications above. Note that it’s applied with \[square@brackets\], just like the hard-coded slice.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; slicer = slice(0,6,2)</p>@<p>&gt;&gt;&gt; type(slicer)</p>@<p>&lt;class ‘slice’&gt;</p>@<p>&gt;&gt;&gt; the_list[slicer]</p>@<p>[0, 2, 4]</p></td>@</tr>@</tbody>@</table><S-CR>Using the **slice** object can make your code much easier to maintain@because you don’t have to fiddle with hard-coded index values. It can be@especially useful if you’re parsing data whose format is likely to@change and over which you have little control (like text scraped from a@web site). A few **slice** objects at the top of your code could make@adjustments / updates a snap. This being said, if its specification is@too “distant” from where it’s being applied your code could become less@transparent for human consumers.<S-CR>Here are a few additional examples of how you might use slices:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_slicer.py</p>@<p>the_string = "strings are sequences with an encoding"</p>@<p>the_list = list(range(0,10))</p>@<p>the_slice = slice(3, 10) # positions 3...9 inclusive</p>@<p>print("Slice : ", the_slice)</p>@<p>print("Slice a list: ", the_list[3:10]) # more typical</p>@<p>print("Alt. syntax : ",</p>@<p>the_list.__getitem__(the_slice)) # more verbose</p>@<p>print("Slice a string: ", the_string[3:10])</p>@<p>print("The whole string: ",the_string[:]) # all</p>@<p>print("Skipping: ",the_string[::2]) # step by 2</p>@<p>new_list = the_list[:] # same as the_list.copy()</p></td>@</tr>@</tbody>@</table><S-CR>This should produce output something like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Slice : slice(3, 10, None)</p>@<p>Slice a list: [3, 4, 5, 6, 7, 8, 9]</p>@<p>Alt. syntax : [3, 4, 5, 6, 7, 8, 9]</p>@<p>Slice a string: ings ar</p>@<p>The whole string: strings are sequences with an encoding</p>@<p>Skipping: srnsaesqecswt necdn</p></td>@</tr>@</tbody>@</table><S-CR>Dictionaries in Python@----------------------<S-CR>Python supports dictionary objects, known to some languages as “hash@tables” or “hash mappings.” The basic object, **dict**, is built into@the language and variants of it, such as the **OrderedDict** are@available in the **collections** library[32].<S-CR>Basics@------<S-CR>A **dict** object is another form of a collection – it has some@important differences from sequence objects like the **list** and@string. Among these:<S-CR>-   Since it’s a hash[33] (optimized for efficiency) the elements are@    not in any guaranteed order. In other words, the act of adding an@    element can change the order of the others.<S-CR>-   Operations like slicing, indexing, etc. are not available because@    they’re dependent on the ordering of the elements.<S-CR>The **dict** is essentially a one-way lookup table. Given a unique key,@one can efficiently find its associated value. However, since values are@not necessarily unique you can’t go the other way (you can’t use a value@to look up a key).<S-CR>Here’s some basic usage:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_dict.py</p>@<p>the_dict = {"key":"value", "A":2, "B":3}</p>@<p>same_dict = dict(key = "value", A = 2, B = 3)</p>@<p>print("Dict compare :", the_dict == same_dict)</p>@<p>print("And here’s the dict:", the_dict)</p>@<p>the_dict[‘C’] = 3</p>@<p>print(.”.. and again:", the_dict)</p>@<p>my_value = the_dict.get(‘D’, "some default value")</p>@<p>print(.”.. and yet again:", the_dict)</p>@<p>print(.”.. (and my_value is: {}).”.format(my_value))</p></td>@</tr>@</tbody>@</table><S-CR>This will produce results as follows:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Dict compare : True</p>@<p>And here’s the dict: {‘A’: 2, ‘B’: 3, ‘key’: ‘value’}</p>@<p>... and again: {‘A’: 2, ‘B’: 3, ‘C’: 3, ‘key’: ‘value’}</p>@<p>... and yet again: {‘A’: 2, ‘B’: 3, ‘C’: 3, ‘key’: ‘value’}</p>@<p>... (and my_value is: some default value)</p></td>@</tr>@</tbody>@</table><S-CR>Using get@---------<S-CR>There are several ways to retrieve elements from a dictionary. Of@particular interest is the **get** method. While it’s completely OK to@call a value out by name, if that value does not exist a **KeyError**@exception will occur. The **get** method allows you to provide some@default value in this case (or if you don’t, a valid **None** object@will be returned). Here’s a quick example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_get.py</p>@<p>"use the dict method get"</p>@<p>plant_dict = {‘raspberry’: ‘rubus’,</p>@<p>‘elm’ : ‘ulmus’,</p>@<p>‘maple’ : ‘acer’</p>@<p>}</p>@<p>#create a format string</p>@<p>fmt_str = "The {} is more properly called a {}."</p>@<p>#get with no argument</p>@<p>look_for = ‘raspberry’</p>@<p>found = plant_dict.get(look_for)</p>@<p>print(fmt_str.format(look_for, found))</p>@<p>#get with a default value</p>@<p>look_for = ‘alder’</p>@<p>default = ‘SOMETHING. I dunno’</p>@<p>found = plant_dict.get(look_for, default)</p>@<p>print(fmt_str.format(look_for, found))</p>@<p>#get with default None</p>@<p>look_for = ‘sumak’</p>@<p>default = None</p>@<p>found = plant_dict.get(look_for, default)</p>@<p>if found:</p>@<p>print(fmt_str.format(look_for, found))</p>@<p>else:</p>@<p>print("Dude, I give up ;-)")</p></td>@</tr>@</tbody>@</table><S-CR>This code will produce the following output:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>The raspberry is more properly called a rubus.</p>@<p>The alder is more properly called a SOMETHING. I dunno.</p>@<p>Dude, I give up ;-)</p></td>@</tr>@</tbody>@</table><S-CR>Keys are Immutable@------------------<S-CR>The keys of a **dict** need to be unique and hashable. As a result, one@of the requirements of a key is that be immutable[34]. To determine@whether a proposed key is hashable, “under the hood” the interpreter@looks for the **\_\_hash\_\_** “magic method”, and uses the hash thus@produced for internal bookkeeping. If there’s no **\_\_hash\_\_**@method, the proposed key won’t qualify. As long as the key meets these@requirements, it can be just about anything, though strings and integers@are most commonly used.<S-CR>Useful Dictionary Methods@-------------------------<S-CR>Here’s a little more code you can use to “kick the tires” on the@**dict** object. Note the use of the **update** method of the **dict**@object and the top-level **del**[35] method.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_dict_1.py</p>@<p>mydict = {}</p>@<p>mydict[‘team’] = ‘Cubs’</p>@<p>#another way to add elements us via update.</p>@<p># For input, just about any iterable that’s comprised of</p>@<p># 2-element iterables will work.</p>@<p>mydict.update([(‘town’, ‘Chicago’), (‘rival’, ‘Cards’)])</p>@<p>#we can print it out using the items method</p>@<p>#(it returns a tuple)</p>@<p>for key, value in mydict.items():</p>@<p>print("key is {} and value is {}.” \</p>@<p>.format(key, value))</p>@<p>print("let’s get rid of a rival")</p>@<p>print()</p>@<p>#<strong>and</strong> evaluates left to right; this protects from crashes</p>@<p>#if no ‘rival’</p>@<p>if "rival" in mydict and mydict[‘rival’] = = ‘Cards’:</p>@<p>#note that del is NOT a dict method</p>@<p>del(mydict[‘rival’])</p>@<p>print()</p>@<p>print("by the grace of a top-level function, \</p>@<p>the Cards are gone.\n")</p></td>@</tr>@</tbody>@</table><S-CR>This code will print the following:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>key is rival and value is Cards</p>@<p>key is town and value is Chicago</p>@<p>key is team and value is Cubs</p>@<p>let’s get rid of a rival</p>@<p>by the grace of a top-level function, the Cards are gone.</p></td>@</tr>@</tbody>@</table><S-CR>You can extract the keys and values by the cleverly-named **keys** and@**values** methods. These return iterable objects containing the@appropriate values.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; the_dict = {"key":"value", "A":2, "B":3}</p>@<p>&gt;&gt;&gt; the_dict.keys</p>@<p>dict_keys([‘A’, ‘key’, ‘B’])</p>@<p>&gt;&gt;&gt; the_dict.values</p>@<p>dict_values([2, ‘value’, 3])</p></td>@</tr>@</tbody>@</table><S-CR>Another way to remove elements from a **dict** is to use its **pop** and@**popitem** methods. These not only remove elements, but return the@element removed. Here’s how you might employ these methods:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_dict_2.py</p>@<p>my_dict = {‘team’: "Cubs", "town": "Chicago", \</p>@<p>"rival": "Cards"}</p>@<p>print("dict is: {}\n”.format(my_dict))</p>@<p>default = None</p>@<p>#use popitem to get some (unknown) item.</p>@<p>#Will crash if dict is empty.</p>@<p>if my_dict:</p>@<p>key, value = my_dict.popitem()</p>@<p>print("we’ve removed: {}\n.”.format(value))</p>@<p>print("dict is now: {}\n.”.format(my_dict))</p>@<p>#with pop we can pick a key and use a default,</p>@<p># just in case</p>@<p>for looking_for in ("house beer", ‘team’):</p>@<p>key_value_tuple = my_dict.pop(looking_for, default)</p>@<p>if key_value_tuple:</p>@<p>print("{} is {}\n.”.format(looking_for, \</p>@<p>key_value_tuple))</p>@<p>else:</p>@<p>print("sorry, no {} here.”.format(looking_for))</p></td>@</tr>@</tbody>@</table><S-CR>This will produce output something like the following. Remember, though@that a **dict** doesn’t guarantee any particular ordering of the@information. Repeated runs of the code will (very likely) produce@different results. You might try it.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>dict is: {‘team’: ‘Cubs’, ‘town’: ‘Chicago’, ‘rival’: ‘Cards’}</p>@<p>town is: Cubs</p>@<p>dict is now: {‘town’: ‘Chicago’, ‘rival’: ‘Cards’}</p>@<p>sorry, no house beer here</p>@<p>sorry, no team here</p></td>@</tr>@</tbody>@</table><S-CR>Sorting a Dictionary@--------------------<S-CR>Occasionally, you’ll want to sort the contents of a **dict**. Sorting by@keys is a snap because they’re guaranteed to be unique and have a@natural “sort order.” This can be accomplished succinctly by applying@the built-in **sorted** method of the **list** object.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; my_dict = {‘team’: "Cubs", "town": "Chicago",</p>@<p>"rival": "Cards"}</p>@<p>&gt;&gt;&gt; print(sorted(list(my_dict.keys())))</p>@<p>[‘rival’, ‘team’, ‘town’]</p></td>@</tr>@</tbody>@</table><S-CR>This probably looks complicated at first glance, but it’s not so tough@when you break it down. Nested functions can be best interpreted “inside@out.”<S-CR>my\_dict.keys() \#gets an iterable of the keys<S-CR>list(my\_dict.keys()) \#converts the iterable to a list<S-CR>sorted(list(my\_dict.keys())) \#sorts alphabetically<S-CR>print(sorted(list(my\_dict.keys()))) \#feeds the sorted **list** to@**print**<S-CR>Sorting by values is a little tougher, but here’s how you can do it. You@need to provide a short routine that returns a value if you give it a@key. If you provide it to the **list** object’s **sort** method[36], it@will use the routine to guide its efforts. We’ll get into functions more@later. For now, know that the general form is:<S-CR>> **def \<function\_name\>():**@>@> **\<indented suite\>**<S-CR>It can take zero or more arguments and optionally return an object of@your choice.<S-CR>The **sort** command by default will sort the elements “naturally” –@alphabetically if strings and numerically otherwise. You can influence@that behavior by giving it something else besides the **list** elements@to sort “naturally”. It could be anything – a random number, word count,@the last letter of a word, etc. Things will be sorted by whatever is@returned by the sorter routine you write.<S-CR>This is what a “null sorter” would look like (it returns exactly what we@passed it):<S-CR><table>@<tbody>@<tr class="odd">@<td><p>def sorter(key):</p>@<p>"simply returns what’s provided i.e., contributes nothing"</p>@<p>return key</p></td>@</tr>@</tbody>@</table><S-CR>Here’s an example of routine that uses a custom sorter that returns the@<span class="underline">value</span> associated with the **dict** key@provided to it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_dict_3.py</p>@<p>def sorter(key):</p>@<p>"simply returns the value"</p>@<p>return my_dict[key]</p>@<p>my_dict = {‘team’: "Cubs", "town": "Chicago", \</p>@<p>"rival": "Cards"}</p>@<p>key_list = list(my_dict.keys())</p>@<p>key_list.sort(key = sorter)</p>@<p>for key in key_list:</p>@<p>print(key, my_dict[key])</p></td>@</tr>@</tbody>@</table><S-CR>And here are the results:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#results</p>@<p>rival Cards</p>@<p>town Chicago</p>@<p>team Cubs</p></td>@</tr>@</tbody>@</table><S-CR>Miscellaneous Notes on dict Objects@-----------------------------------<S-CR>You can use dictionaries to hold elements of sparse arrays by using@**tuple**s as keys. Let's say you wanted to model movements of goldfish@in a tank. You could account for each cubic centimeter of water and@monitor each fish passage in and out – you might use a dense 3-D array@for that. Perhaps more efficiently, you could monitor the fish@themselves by providing a three-**tuple** to represent the current@location of each. This **dict** uses **tuples** for keys:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; array_dict = {(0, 0, 0): 12, (2, 4, 98): 23}</p>@<p>&gt;&gt;&gt; array_dict[(2, 4, 98)]</p>@<p>23</p></td>@</tr>@</tbody>@</table><S-CR>Keys can be heterogeneous, as can the values. This is a valid **dict**:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; hetero_dict = {‘a’: 1, (1,3,4): "x"}</p>@<p>&gt;&gt;&gt; hetero_dict</p>@<p>{‘a’: 1, (1, 3, 4): ‘x’}</p></td>@</tr>@</tbody>@</table><S-CR>If a **dict** has a key named “a”, and you provide a new element who’s@key is ‘a’, the original will be replaced.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; new_dict = dict( ( (‘a’, 3), (‘b’, 88) ) )</p>@<p>&gt;&gt;&gt; new_dict</p>@<p>{‘a’: 3, ‘b’: 88}</p>@<p>&gt;&gt;&gt; new_dict[‘a’] = "Godzilla!"</p>@<p>&gt;&gt;&gt; new_dict</p>@<p>{‘a’: ‘Godzilla!’, ‘b’: 88}</p></td>@</tr>@</tbody>@</table><S-CR>Adding elements one at a time can be expensive, especially as the@**dict** grows. That’s because the entire object needs to be copied to a@new patch of memory if it grows past its allocated space. It’s more@efficient to use an *en masse* operation like **update**.<S-CR>The set Object and List Comprehension@-------------------------------------<S-CR>The **set** object is a mighty useful arrow in your quiver. A **set** is@essentially a collection of unique objects. The **set** is another hash@object, making retrieval of objects very efficient, even when the@**set** is large.<S-CR>The fact that a **set** contains only unique objects makes it great for@an automatic de-duplicator. If you try to add an object that already@exists, the attempted addition fails silently. Here’s a common idiom to@de-dup a **list**:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; set([1,1,2,2,2,3,3,4,5])</p>@<p>{1, 2, 3, 4, 5}</p></td>@</tr>@</tbody>@</table><S-CR>Here’s a slightly more complicated example, this one using a “list@comprehension” to create a set of random numbers using the random@library:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_list_comp.py</p>@<p>import random</p>@<p>values = 1000</p>@<p>dedup = set([int(1000*random.random()) \</p>@<p>for i in range(values)])</p>@<p>print("we found {} unique values!”.format(len(dedup)))</p>@<p>#sample output (YMMV)</p>@<p>#we found 384 unique values from an initial sample of 1000</p></td>@</tr>@</tbody>@</table><S-CR>The list comprehension[37] bit bears some explanation. It’s just a@short-cut way to build a **list**. This bit does the heavy lifting:<S-CR>|                                                       |@|-------------------------------------------------------|@| \[int(1000\*random.random()) for i in range(values)\] |<S-CR>… broken down, it’s the same as this more verbose version:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>random_list = []</p>@<p>for i in range(values):</p>@<p>rand_num = random.random()</p>@<p>rand_int = int(rand_num * 1000)</p>@<p>random_list.append(rand_int)</p>@<p>dedup = set(random_list)</p></td>@</tr>@</tbody>@</table><S-CR>**Sets** have built-in methods for efficiently finding unions and@intersections. A union is a **set** of every unique element from both@sets combined. An intersection is a **set** of the elements found in@both. This code serves to illustrate how you might apply them using the@“**&**” and “**\|**” operators:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_set_operations.py</p>@<p>the_set = {"monkey", "gorilla", "dog", "cat"}</p>@<p>print("Set: ", the_set)</p>@<p>the_set.add("parrot")</p>@<p>print("Set: ", the_set)</p>@<p>other_set = {"gorilla", "elephant", "pig", "chicken"}</p>@<p>print("Set intersection:", the_set &amp; other_set)</p>@<p>print("Set union:", the_set | other_set)</p></td>@</tr>@</tbody>@</table><S-CR>The code yields the following output:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Set: {‘gorilla’, ‘monkey’, ‘cat’, ‘dog’}</p>@<p>Set: {‘gorilla’, ‘monkey’, ‘parrot’, ‘cat’, ‘dog’}</p>@<p>Set intersection : {‘gorilla’}</p>@<p>Set union: {‘dog’, ‘gorilla’, ‘monkey’, ‘elephant’,</p>@<p>‘pig’, ‘parrot’, ‘cat’, ‘chicken’}</p></td>@</tr>@</tbody>@</table><S-CR>Note that although this example uses the "\|" and "&" operators with two@**set** objects, there's no limit to the number of objects in play. If@a, b, and c are all **sets**, you can go a&b&c or a\|b\|c.<S-CR>Named Tuples@------------<S-CR>**The namedtuple** object is something of a hybrid between a **tuple**@and a **dict**. Each **namedtuple** can be instantiated into your@current namespace as a ‘normal’ **tuple**, but the wrinkle is that you@can provide each element an alias (nickname) so you can refer to it@easily. It’s not part of basic Python so you need to **import** it from@the collections library.<S-CR>Here’s some code to play with which shows the basic functionality. Note@that you can address these objects like dictionaries, but can also use@them as **tuples**.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_animals.py</p>@<p>"""An introduction to the namedtuple object"""</p>@<p>&gt;&gt;&gt; from collections import namedtuple</p>@<p>#make a tuple with the tag ‘Animal’</p>@<p>&gt;&gt;&gt; Animal = namedtuple(‘Animal’, (‘species’, ‘name’))</p>@<p>#specify this animal by providing the species and name</p>@<p>&gt;&gt;&gt; a1 = Animal(‘gorilla’, ‘magilla’)</p>@<p>&gt;&gt;&gt; print(a1)</p>@<p>Animal(species='gorilla', name='magilla')</p>@<p>#... and specify another</p>@<p>&gt;&gt;&gt; a2 = Animal(species = ‘gorilla’, name = ‘fred’)</p>@<p>&gt;&gt;&gt; print(a2)</p>@<p>Animal(species='gorilla', name='fred')</p>@<p>#we can call out the specifics using dot notation</p>@<p>&gt;&gt;&gt; print(a1.name, a2.name)</p>@<p>magilla fred</p>@<p>#... or, split the tuple containing the first animal</p>@<p>&gt;&gt;&gt; myspecies, myname = a1</p>@<p>&gt;&gt;&gt; print(myspecies, myname)</p>@<p>gorilla, magilla</p></td>@</tr>@</tbody>@</table><S-CR>Getting Fancier with the namedtuple Object@------------------------------------------<S-CR>Here’s a slightly more complicated example – something you might use if@you were developing a chess game in Python. We won’t elaborate this to@completion – but it may be interesting practice. If you do the upgrade,@you might look into using Unicode to represent your chess pieces[38]@(Python 3 is Unicode-compliant[39]).<S-CR>This code develops a two-dimensional grid using a **list** of@**namedtuple** objects. This is a simple way to whistle up a 2-d@array-like structure using only basic Python tools.<S-CR>You can see that each of the **namedtuple** objects carries with several@properties, nicely bundled, and transparently addressed. In this sense,@the objects we’re creating here are a bit like the build-in Python@objects – they’re already endowed with “out of the box” capabilities.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_named_tuples.py</p>@<p>from collections import namedtuple</p>@<p>Piece = namedtuple(‘Piece’, ‘type color position symbol’)</p>@<p>#a list of lists is a really useful data structure</p>@<p>grid = []</p>@<p>for r in range(8):</p>@<p>grid.append([None, None, None, None,</p>@<p>None, None, None, None])</p>@<p>grid[7] = [</p>@<p>Piece("Rook" , "black", [7,0], "R"),</p>@<p>Piece("Knight" , "black", [7,1], "K"),</p>@<p>Piece("Bishop" , "black", [7,2], "B"),</p>@<p>Piece("Queen" , "black", [7,3], "Q"),</p>@<p>Piece("King" , "black", [7,4], "K"),</p>@<p>Piece("Bishop" , "black", [7,5], "B"),</p>@<p>Piece("Knight" , "black", [7,6], "K"),</p>@<p>Piece("Rook" , "black", [7,7], "R") ]</p>@<p>grid[6] = [ ]</p>@<p>for c in range(8):</p>@<p>p = Piece("Pawn", "black", [6,c], "P")</p>@<p>grid[6].append(Piece("Pawn", "black", [6,c], "P"))</p>@<p>for p in grid[7]:</p>@<p>print(p.symbol, end = "")</p>@<p>print()</p>@<p>for p in grid[6]:</p>@<p>print(p.symbol, end = "")</p>@<p>print()</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>#output:</p>@<p>RKBQKBKR</p>@<p>PPPPPPPP</p></td>@</tr>@</tbody>@</table><S-CR>Copying Sequences@-----------------<S-CR>In Python, it’s possible to have multiple names associated with the same@object. This can be really handy but the convenience comes with a cost:@the only way to tell for sure is with the object’s **id**. Here are a@couple trivial examples that show the potential pitfalls:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; one = 1</p>@<p>&gt;&gt;&gt; one_prime = 1</p>@<p>&gt;&gt;&gt; id(one)</p>@<p>30396760</p>@<p>&gt;&gt;&gt; id(one_prime) #same object !!!</p>@<p>30396760</p></td>@</tr>@</tbody>@</table><S-CR>You run into this with collections, too. This code will demonstrate:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_list_copy.py</p>@<p>def test_lists(first, second):</p>@<p>test_result = (first = = second)</p>@<p>print("same list, right? {}.”.format(test_result))</p>@<p>if test_result = = False:</p>@<p>print("first id is {} second id is {}.”\</p>@<p>.format(id(first), id(second)))</p>@<p>print(‘make a list, then create a copy’)</p>@<p>a_list = ["Tony", "Sally", "George"]</p>@<p>b_list = a_list</p>@<p>print(a_list, b_list)</p>@<p>test_lists(a_list, b_list)</p>@<p>#update the first list, but not the second.</p>@<p>print("\nadd someone to the a_list, \</p>@<p>leaving the b_list alone")</p>@<p>a_list.append("Sam")</p>@<p>test_lists(a_list, b_list)</p>@<p>print("Uh, what happened here?")</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>#output:</p>@<p>make a list, then create a copy</p>@<p>[‘Tony’, ‘Sally’, ‘George’] [‘Tony’, ‘Sally’, ‘George’]</p>@<p>same list, right? True</p>@<p>add someone to the a_list</p>@<p>same list, right? True</p>@<p>Uh, what happened here?</p></td>@</tr>@</tbody>@</table><S-CR>“What happened here” is that we have simply assigned two names to the@same object (they have the same **id**). To get around this, you need to@make a “deep” (true) copy. Here are some ways to do it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; new = old[:] #forces the list to iterate over itself</p>@<p>&gt;&gt;&gt; new = list(old) #list constructor creates new object</p>@<p>&gt;&gt;&gt; new = old.copy() #uses the list object’s copy method</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise:</p>@<p>I just hired a new admin and it’s not working out so well. I asked her to organize my Cubs player database. It turned out to be a disaster. After she quit, I found two versions of the database. Can you help? One version of the database (stored as a <strong>dict</strong>) uses the players’ weights as the key. I’ll spare the details, but it looks like this:</p>@<p>#py_cubs_players.py</p>@<p>players = {185:(‘Tyler’, ‘Chatwood’),</p>@<p>219:(‘Luke’, ‘Farrell’),</p>@<p>190:(‘Kyle’, ‘Hendricks’)}</p>@<p>Can you find a way, working only with code and this dictionary, to produce a nicely formatted table that’s sorted by the players’ last name?</p>@<p>The other version was only a little better and organized by last name – sort of. There were lots of duplications caused by bad typing. Here’s a bit of it:</p>@<p>players = {‘Hendricks’: (‘Kyle’, 225),</p>@<p>‘HeNDricks’: (‘Kyle’, 225),</p>@<p>‘Hendrix’: (‘Kyle’, 225) }</p>@<p>Can you find a way to clean this version up working with the <strong>set</strong> object<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>?sort of organizing the data by player weightide it to te</p></td>@</tr>@</tbody>@</table>@<section class="footnotes" role="doc-endnotes">@<hr />@<ol>@<li id="fn1" role="doc-endnote"><p>It’s beyond the scope of this class, but just for fun you might look at the code in py_fuzzy_lookup.py. For ways to further refine. It demonstrates a tool that will let you find and score “fuzzy” (inexact) matches.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>@</ol>@</section><S-CR>Functions@=========<S-CR>Functions are just bits of code that encapsulate – you guessed it –@functionality. We’ll explore them in some depth in this chapter.<S-CR>You’ve already used several of them like **print**, **input**, and@**bin**. You’ve used them with commands like **list.sort** – though,@technically when contained within classes, they’re called “methods.” And@we’ve just written a small function to sort **dict** objects by value.@You’re already a getting to be a pro. You’ll become more so by rolling a@few of your own.<S-CR>Scope of Names In a Module@--------------------------<S-CR>Here are a couple example functions that each take a single, positional@parameter. The first is pretty straightforward, and the second@introduces the **global** keyword.<S-CR>In Python (and all languages) there’s a notion of “scope” – that’s the@part of the code where a variable is visible. Indentation levels are a@good gauge of scope within a module. The objects defined in the first@column (setStar function and the variables STAR, Favorites and X) are@visible throughout the module and are called “globals”[40]. Variables@tucked away within a function e.g., title\_length in section are visible@only within that function, normally. These are called “locals”[41].<S-CR>If you want to enhance the visibility of the variable and make it global@to the module, you can employ the **global** keyword, as is done in@SetStar for the variable STAR. Once you do that, you facilitate “two way@communication” with that STAR object and allow the function to alter the@value . If you don’t do that, the function can only alter the “local@copy” of STAR[42].<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_function_1.py</p>@<p># Globals namespace</p>@<p>STAR = "Sirius" # Polaris</p>@<p>Favorites = [ ]</p>@<p>X = 100</p>@<p>def setStar(name):</p>@<p>"Local namespace"</p>@<p>#remove comment to map to global namespace</p>@<p>#global STAR</p>@<p>STAR = name</p>@<p>Favorites.append(name)</p>@<p>print("STAR: ", STAR)</p>@<p>setStar("Polaris")</p>@<p>print("STAR: ", STAR)#output</p></td>@</tr>@</tbody>@</table><S-CR>Passing Information into a Function@-----------------------------------<S-CR>You have a tremendous amount of flexibility around how, and whether, to@pass information into functions. You can “roll your own” from some@combination of fixed positional arguments (a contract between you and@your function to provide a precise number or arguments); positional@“wildcard” arguments (0 to a zillion arguments); specific key / value@pairs; or “wildcard” key / value pairs (0 to a zillion). Here are some@examples of the options available to you:<S-CR>The simplest of all functions can be constructed like this:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>def simple():</p>@<p>“a docstring, or the keyword pass”</p></td>@</tr>@</tbody>@</table><S-CR>You need the keyword **def**, some name, enclosing parentheses and a@colon in the header; a nominal indented suite following. This function@takes no arguments and returns **None**. Not so interesting, really, but@syntactically-correct. You can upgrade in a variety of ways. If you have@only named positional parameters as with this constructor:<S-CR>|                                               |@|-----------------------------------------------|@| def positional\_only(input1, input2, input3): |<S-CR>Here you promise three inputs – no more and no fewer. Sometimes, though,@you really don’t know how many bits of information you’ll get and want@to generalize. Python provides flexibility when the number of arguments@is unpredictable. This constructor requires one positional argument then@zero or more additional ones:<S-CR>|                                               |@|-----------------------------------------------|@| def positional\_plus(input1, \*more\_inputs): |<S-CR>The “\*” signals the interpreter to expect a tuple of unknown size, and@to create a local name “more\_inputs” tied to a **tuple** object (you@don’t use the \* inside the function). The **tuple** will scoop all the@additional arguments provided beyond the first one (that’s assigned to@input1). If only argument is provided the **tuple** will be empty.<S-CR>If you want to use a **dict** as input, you can construct the function@like this:<S-CR>|                                     |@|-------------------------------------|@| def dict\_only(a = None, b = None): |<S-CR>This is a handy idiom because objects a and b are always created when@the function is called. That makes them optional – neither, either, or@both can be used when calling it. Another way to use a **dict** is to@use a placeholder for one with a constructor that looks like this:<S-CR>|                                         |@|-----------------------------------------|@| def dict\_placeholder(\*\*input\_dict): |<S-CR>When you do this, you create a local name “input\_dict” that’s tied to@the key:value pairs provided when the function is called (you don’t use@the \*\* internally). Let’s take a look at a couple more examples.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_function_2.py</p>@<p>def eats(*foods): # gather positional args in a tuple</p>@<p>print("foods: ", foods) # foods is a tuple now</p>@<p>print("Tuple of positional arguments to eats():")</p>@<p># open-ended number of positional arguments passed in...</p>@<p>eats("Spaghetti", "Oysters", "Chili", "Crackers", "Rice")</p>@<p>def example(*args, **kwargs): # keyword args dict</p>@<p>"""</p>@<p>(* ) convert positionals --&gt; tuple</p>@<p>(**) convert keyword args --&gt; dict</p>@<p>"""</p>@<p>for arg in args: # loop over the tuple</p>@<p>print(arg, sep = ", ", end = "")</p>@<p>print()</p>@<p>for key, value in kwargs.items(): # ...now the dict</p>@<p>print("Arg name:",key,"Value: ", value)</p>@<p># positional + keyword (named) arguments</p>@<p>example( 1,2,3,4, on_vacation = True, at_work = False )</p>@<p># same thing using "exploders" * and **</p>@<p>example( *(1,2,3,4), **dict(on_vacation = False,</p>@<p>at_work = True) )</p></td>@</tr>@</tbody>@</table><S-CR>As you can see, you’ve got plenty of options here. This being said,@there are a couple of constraints. The order is important – the@positional arguments need to come first, then the **tuple** of arbitrary@size, then the dictionary. As soon as the interpreter hits the **tuple**@argument, it’s game over for positional arguments. As soon as it hits@the dictionary, it’s game over for both positional arguments and@**tuples**.<S-CR>Returning Information From a Function@-------------------------------------<S-CR>A function does not have to return anything. If it does return@something, you don’t have to give the returned value a name or otherwise@use it. All of these work[43]:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; def yowza():</p>@<p>return "yowza"</p>@<p>&gt;&gt;&gt; yowza()</p>@<p>‘yowza’</p>@<p>&gt;&gt;&gt; a = yowza()</p>@<p>&gt;&gt;&gt; a</p>@<p>‘yowza’</p>@<p>&gt;&gt;&gt; def hiya():</p>@<p>pass</p>@<p>&gt;&gt;&gt; hiya()</p></td>@</tr>@</tbody>@</table><S-CR>Personally, I think it’s a good idea to return something – even if it’s@just the number 1 to show “Yup, I executed” or a -1 to show “Uh, there@was a problem.” But it’s up to you – without instructions in this regard@a function returns the **None** object.<S-CR>Finally, in Python you can only return one object. This isn’t@necessarily an issue because the object can be as complex as it needs to@be to fully “pass the baton” to the next routine. The **dict** is my “go@to” object for complex returns – mostly because it can be as complex as@it needs to and, properly done, completely self-documenting.<S-CR>First Class Objects@-------------------<S-CR>Functions are known as “first class objects” because they can be used@just as classes and other top-level objects in Python. For instance,@they can be passed as arguments to other functions without issue[44].@This is really powerful because you can separate responsibilities@cleanly between separate, isolated bits of code. As a result, different@teams can work on the individual functions and atomic tests can be@written against the capabilities promised by each function. All this@makes a “divide and conquer” approach to development a snap and –@perhaps more importantly – can keep code easy to maintain as@requirements change.<S-CR>Here’s how you might use functions’ “first class” status Python to take@a foray into functional programming. For this example, imagine we have@the “F team” in Florida and that it’s never met the “G team” in Georgia.@Each has been working 24/7 on its task, has written tests, and otherwise@has things dialed in. F has perfected the art of doubling a value and G@has nailed adding 2 to a value.<S-CR>As consumers of these efforts, we can “stand on the shoulders of giants”@and repurpose / combine the efforts into our own project. Here’ s an@example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_function_3.py</p>@<p>def compose(g, f):</p>@<p>"""Take two functions as inputs and return a</p>@<p>function that’s their composition"""</p>@<p>def newfunc(x):</p>@<p>return g(f(x))</p>@<p>return newfunc</p>@<p># input function</p>@<p>def G(n):</p>@<p>return n + 2</p>@<p># input function</p>@<p>def F(n):</p>@<p>return n * 2</p>@<p># compare:</p>@<p>H = compose(G, F) # build a 3rd function from 1 &amp; 2</p>@<p>print("G(F(x)):", H(100)) # G(F(x))</p>@<p># ... now with</p>@<p>H = compose(F, G)</p>@<p>print("F(G(x)):", H(100)) # F(G(x))</p>@<p>#output</p>@<p># G(F(x)): 202</p>@<p>#F(G(x)): 204</p></td>@</tr>@</tbody>@</table><S-CR>Function Exotics@----------------<S-CR>There are a few other ways that functions are used that may be of@interest in your programming career. If you don’t master these@applications right away – no worries. The idea is to show you they exist@and how to interpret what may look like very funky code in the new@libraries you’ll likely explore.<S-CR> Inner Functions@---------------<S-CR>It’s possible for a function to contain other functions called “inner@functions.” In this case, not only is there an inner function, but@that’s what gets returned. The object that gets returned is “loaded for@bear”, retaining the information originally passed into **addLetters**.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_function_4.py</p>@<p>def addLetter(letters): # &lt;-- pass in a string</p>@<p>"""</p>@<p>A function factory builds and returns function objects.</p>@<p>L is a function that will add whatever letters are passed</p>@<p>in to be the ending letters.</p>@<p>"""</p>@<p>def L(s):</p>@<p>return s + letters</p>@<p>return L</p>@<p>#these are functions (versions of the inner</p>@<p>#function L() returned from addLetters()</p>@<p>add_s = addLetter("s")</p>@<p>add_ed = addLetter("ed")</p>@<p>print(add_ed)</p>@<p>#and we can execute these functions like any others</p>@<p>print(add_s('Unhinged rant'))</p>@<p>print(add_ed('In an unhinged fashion rant'))</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>#output</p>@<p># &lt;function addLetter.&lt;locals&gt;.L at 0x000000000329AE18&gt;</p>@<p># Unhinged rants</p>@<p># In an unhinged fashion ranted</p></td>@</tr>@</tbody>@</table><S-CR>Closures@--------<S-CR>A closure is an inner function with a memory. Let’s say that you have on@good authority that the meaning of life is 42. You want to stash that@pearl of insight away and be prepared to tweak it as life gets more@interesting and the universe evolves.<S-CR>You might want to create a Python function to which you can provide the@original value. Then you might ask the main function to return another@function that accepts your changes. Here’s how you might do it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_function_5.py</p>@<p>def outer_space(outer_input):</p>@<p>"outer-most function"</p>@<p>last_answer=outer_input</p>@<p>def inner_space(inner_input):</p>@<p>"inner-most function"</p>@<p>nonlocal last_answer</p>@<p>last_answer += inner_input</p>@<p>return last_answer</p>@<p>return inner_space</p>@<p>MEANING_OF_LIFE=42</p>@<p>original = outer_space(MEANING_OF_LIFE)</p>@<p>print("The original meaning of life is {}".format(original(0)))</p>@<p>tweak=3</p>@<p>new_meaning = original(tweak)</p>@<p>print("But now we think it's a bit more: {}".format(new_meaning))</p>@<p>next_new_meaning = original(tweak)</p>@<p>print("... and now: {}".format(next_new_meaning))</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>#output</p>@<p>The original meaning of life is 42</p>@<p>But due to reasons known only to me it is probably 45</p>@<p>... and now 48</p></td>@</tr>@</tbody>@</table><S-CR>As you can see, the inner function retained some “institutional memory”,@encapsulated it, and made itself available for further interaction.<S-CR>The **nonlocal** keyword, introduced here, acts to make a variable in an@inner function available to the outer one. This is precisely the@relationship that the **global** keyword in the outer function has with@the containing module.<S-CR> Python’s Take on Map, Reduce and Filter@---------------------------------------<S-CR>Python has some limited built-in capability to handle map/reduce@operations. It can easily perform the same sort of analysis possible@with big data analytical tools like Hadoop, but just not at the same@scale. (Hadoop has its own way to manage workload and file systems –@that’s where its real magic lies).<S-CR>In a nutshell, a map operation is one that iterates through a bunch of@objects and does the same thing to each one. A reduce operation sifts@through the mapped objects and filters out the “good stuff.” Generally@speaking, the **map** function is run once then sifted through multiple@times by different reducers.<S-CR>To implement mapping in python, we can use the **map** function. Its@syntax is straightforward:<S-CR>mapped\_data = map (\<processing\_function\>, \<iterable\>)<S-CR>To filter data, we can call upon the **filter** function. It works@pretty much like map, but the processing filter passed judgment on each@element of the iterable objects by evaluating it **True** or **False**.@The result is another iterable of only those that have been deemed@**True**. The syntax is identical to that of **map**:<S-CR>filtered\_data = filter(\<processing\_function\>, \<iterable\>)<S-CR>Here’s an example of how you might use **map** and **filter** to find@even sums of integers provided as **tuples**. These methods are@interesting because they each take two arguments: incoming data and the@name of the routine to process the data. Each returns a generator-like@object. This means they don’t process all the data at once. Instead,@they proceed one step at a time through their task, then only when@requested. This sort of “lazy execution” makes handling of even large@data sets possible because only the bits of it that are being processed@need be in the memory.<S-CR>Python also has a **reduce** method – it works pretty much like **map**,@except the operations defined in the function are applied cumulatively.@Note that it’s implemented using a **lambda** expression[45] (an@anonymous “one liner” function that can be used in place of a standard@function).<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_function_6.py</p>@<p>from functools import reduce</p>@<p>def add_numbers(things_to_add):</p>@<p>"adds two numbers"</p>@<p>first, second=things_to_add</p>@<p>return first+second</p>@<p>def find_evens(thing_to_evaluate):</p>@<p>"returns True if even"</p>@<p>return not thing_to_evaluate % 2 #True if 0, False otherwise</p>@<p>integers=[ (2,2), (4,4), (5,6), (7,8) ]</p>@<p>mapped_data=map(add_numbers, integers)</p>@<p>filtered_results=filter(find_evens, mapped_data)</p>@<p>print("The even sums are {}".format(list(filtered_results)))</p>@<p>cumulative_mult = reduce(lambda x, y: x*y, [1,2,3,4,5])</p>@<p>print("reduce returned: {}".format(cumulative_mult))</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>#output</p>@<p>The even sums are [4, 8]</p>@<p>reduce returned: 120</p></td>@</tr>@</tbody>@</table><S-CR> Function Dispatch@-----------------<S-CR>Python doesn’t have a statement like **case** or **switch**, for better@or worse. However, there are other ways to get the same functionality.@We’ve already seen that a complex **if** .. **elif** .. **else**@structure can accommodate this. However, this can get unwieldy and hard@to maintain.<S-CR>An alternative, and potentially more robust, approach involves mapping@functions to a dictionary, which is then used to dispatch the function.@The following example shows how you might implement such a beast and,@for good measure, introduces the **random.choice** method.<S-CR>As you review the code, imagine how much easier it would be to maintain@than strictly branching logic. Let’s say your client suddenly asked you@to add a new capability – **str**.**title** how could you add it while@minimally touching the existing code[46]?<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_function_7.py</p>@<p>from random import choice</p>@<p>def f_upper():</p>@<p>return str.upper</p>@<p>def f_lower():</p>@<p>return str.lower</p>@<p>def f_swap():</p>@<p>return str.swapcase</p>@<p>function_mapper={'up': f_upper, 'lower': f_lower, 'swap': f_swap}</p>@<p>choices = ['up', 'lower', 'swap']</p>@<p>my_string='Lions and Tigers and Bears, Oh MY!'</p>@<p>for i in range(3):</p>@<p>mychoice=choice(choices)</p>@<p>print(function_mapper[mychoice]()(my_string))</p>@<p>#results will be something like (YMMV - it’s random)</p>@<p>#lIONS AND tIGERS AND bEARS, oH my!</p>@<p>#lions and tigers and bears, oh my!</p>@<p># LIONS AND TIGERS AND BEARS, OH MY!</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>#output (YMMV due to random.choice())</p>@<p>lIONS AND tIGERS AND bEARS, oH my!</p>@<p>LIONS AND TIGERS AND BEARS, OH MY!</p>@<p>LIONS AND TIGERS AND BEARS, OH MY!</p></td>@</tr>@</tbody>@</table><S-CR>The **random**.**choice** method is a convenient way to make a (pseudo)@random choice from a collection of options.<S-CR>The **print** is a bit of a mouthful, so let’s break it down:<S-CR>mychoice \#returns ‘up’<S-CR>function\_mapper\[‘up’\] \#f\_upper<S-CR>function\_mapper\[mychoice\]() \#str.upper function<S-CR>function\_mapper\[mychoice\]()(my\_string)) \#str.upper(my\_string)<S-CR>Note that most of what we’re doing is passing around the name of a@function, like **f\_upper** or **str.upper** without actually executing@it. This allows fairly succinct code because we can chain operations@together in a single line. Is the virtue of being compact outweighed by@the vice of being tough to decipher?<S-CR>Awesome job so far, guys! This has been a long session, but functions@(and methods in classes) are one of the most important building blocks@of any serious programming effort. Let’s try out your new skills on a@couple of problems:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercises:</p>@<blockquote>@<p>Python’s built-in title casing routine has much to be desired. Check this out:</p>@</blockquote>@<p>&gt;&gt;&gt; lst = ["shot in the dark",</p>@<p>"guido van rossum",</p>@<p>"monty python’s life of brian"]</p>@<p>&gt;&gt;&gt; for item in lst:</p>@<p>... print(item.title())</p>@<p>Shot In The Dark</p>@<p>Guido Van Rossum</p>@<p>Monty Python’S Life Of Brian</p>@<p>In the first instance, a really short word got capitalized. The second will drive much European nobility mad because “von” and “van” are generally lower case. And the first letter after an apostrophe is almost never capitalized.</p>@<p>Please see if you can write a function to address these issues – I’m sure you can do better than <strong>str.title</strong>! While you’re about it, see you can break the task down into small, atomic bits. That’ll make it easier to test and maintain. You might use a series of functions something like:</p>@<p>def process_list() -&gt; def process_title() -&gt; def process_word() -&gt; def process_apostrophe()</p>@<blockquote>@<p>-&gt; def process_royalty()</p>@</blockquote>@<p>Feel free to grab code from solution _python_1_chapter05_starter_code.py if you’d like. Many of the mechanics have been worked out, but it would benefit from reorganization.</p></td>@</tr>@</tbody>@</table><S-CR>Modules and Libraries@=====================<S-CR>Python has several built-in object types that provide a versatile and@“off the shelf” collection of tools for handing information you’ll@encounter in real-world situations. This chapter discusses and@demonstrates a few of the libraries (modules) that you can **import**@into your code. We’ll look at just how you can access these libraries@while managing how they work and play with the applications you are@developing.<S-CR>Importing Libraries@-------------------<S-CR>As you’ve seen, the way to access libraries to extend Python’s core@capabilities is to **import** them into your program’s namespace. Here@are some examples:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>import time</p>@<p>from decimal import Decimal, getcontext</p>@<p>from fractions import Fraction as Q # rational number</p>@<p>from datetime import datetime, timezone</p>@<p>from collections import namedtuple</p></td>@</tr>@</tbody>@</table><S-CR> Basic Use of import@-------------------<S-CR>If you examine these commands carefully, you’ll note several variants.@The first example adds the module **time** into your code. We can use@the **dir** keyword to capture the namespace. If used without arguments,@it grabs the global namespace; with an argument, it reports on the@namespace of the object presented in the argument.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dir()</p>@<p>[‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’]</p>@<p>&gt;&gt;&gt; import time</p>@<p>&gt;&gt;&gt; dir()</p>@<p>[‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’, <strong>‘time’</strong>]</p></td>@</tr>@</tbody>@</table><S-CR>The act of importing the new module doesn’t directly bring all the@elements of the **time** module's namespace into your module – you only@have access to **time**. The **time** module, however, has its own@namespace. You can take a look at it using the **dir** function:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dir(time)</p>@<p>[‘CLOCK_MONOTONIC’, ‘CLOCK_MONOTONIC_RAW’, ‘CLOCK_PROCESS_CPUTIME_ID’, ‘CLOCK_REALTIME’, ‘CLOCK_THREAD_CPUTIME_ID’, ‘_STRUCT_TM_ITEMS’, ‘__doc__’, ‘__file__’, ‘__loader__’, ‘__name__’, ‘__package__’, ‘altzone’, ‘asctime’, ‘clock’, ‘clock_getres’, ‘clock_gettime’, ‘clock_settime’, ‘ctime’, ‘daylight’, ‘get_clock_info’, ‘gmtime’, ‘localtime’, ‘mktime’, ‘monotonic’, ‘perf_counter’, ‘process_time’, ‘sleep’, ‘strftime’, ‘strptime’, ‘struct_time’, ‘time’, ‘timezone’, ‘tzname’, ‘tzset’]</p></td>@</tr>@</tbody>@</table><S-CR> Dot Notation @------------<S-CR>While it’s isolated from that of your own namespace, you can still@access the new elements. You can do this by using “dot notation.”<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; time.timezone</p>@<p>28800</p>@<p>&gt;&gt;&gt; time.time</p>@<p>&lt;built-in function time&gt;</p>@<p>&gt;&gt;&gt; time.time()</p>@<p>1474842731.612741</p></td>@</tr>@</tbody>@</table><S-CR>The “dot” delimits namespaces, which may be configured hierarchically,@and allows your code to be specific in terms of exactly which object it@addresses. In the code above, you’ll see that within the **time** module@there is a built in function of the same name. This creates no conflict@for our own module because only the name of the newly-imported module is@visible.<S-CR>Because of this separation it is completely safe to import several@different modules without being concerned about whether object names@from one can “overwrite” those of another.<S-CR>It’s also possible to reach into an external module and import only the@bits we want into our local namespace. Observe the effects of importing@the **Decimal** class and the **getcontext** function into a fresh@instance of the Python interpreter. After the **import**, we now can@access to the external objects on a “first name” basis.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dir()</p>@<p>[‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’]</p>@<p>&gt;&gt;&gt; from decimal import Decimal, getcontext</p>@<p>&gt;&gt;&gt; dir()</p>@<p>[‘<strong>Decimal</strong>’, ‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’, ‘<strong>getcontext</strong>’]</p>@<p>&gt;&gt;&gt; Decimal</p>@<p>&lt;class ‘decimal.Decimal’&gt;</p>@<p>&gt;&gt;&gt; getcontext</p>@<p>&lt;built-in function getcontext&gt;</p></td>@</tr>@</tbody>@</table><S-CR> Renaming Object When Importing@------------------------------<S-CR>A slight variant of this is to choose a name for the imported object@that suits your purpose. Python is agnostic relative to the name you@choose, within its basic rules.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dir()</p>@<p>[‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’]</p>@<p>&gt;&gt;&gt; from fractions import Fraction as Q</p>@<p>&gt;&gt;&gt; dir()</p>@<p>[<strong>‘Q’</strong>, ‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’]</p></td>@</tr>@</tbody>@</table><S-CR>It might make sense to import an object by a specific name to avoid a@namespace collision, or to follow a conventions adapted by your@teammates. For instance, it’s typical to use **numpy** by going:<S-CR>|                           |@|---------------------------|@| \>\>\> import numpy as np |<S-CR>This is done mostly for brevity. It’s much easier to type “np” than@“numpy” - especially if you have to do it thousands of times.<S-CR>Avoid renaming imported objects unless you’ve got a good reason to do so@because it could confuse your team. For instance, you can do one or both@of these:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; import string</p>@<p>&gt;&gt;&gt; string.ascii_uppercase</p>@<p>‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’</p>@<p>&gt;&gt;&gt; import string as elephant</p>@<p>&gt;&gt;&gt; elephant.ascii_uppercase</p>@<p>‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’</p></td>@</tr>@</tbody>@</table><S-CR>… however, if you did the latter you could sow much confusion.<S-CR> “Star Treatment”@----------------<S-CR>Also, while it’s possible to import the entire namespace of a library@into your code, you typically don’t want to do so. In this example we@import the entire **string** module’s namespace using “star notation”:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; dir()</p>@<p>[‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’]</p>@<p>&gt;&gt;&gt; from string import *</p>@<p>&gt;&gt;&gt; dir()</p>@<p>[‘ChainMap’, ‘Formatter’, ‘Template’, ‘__builtins__’, ‘__doc__’, ‘__loader__’, ‘__name__’, ‘__package__’, ‘ascii_letters’, ‘ascii_lowercase’, ‘ascii_uppercase’, ‘capwords’, ‘digits’, ‘hexdigits’, ‘octdigits’, ‘printable’, ‘punctuation’, ‘whitespace’]</p></td>@</tr>@</tbody>@</table><S-CR>While this might be manageable, what if you were already using a@variable called “digits”?<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; digits = [‘thumb’, ‘pointer’, ‘middle’,</p>@<p>‘ring’, ‘pinky’]</p>@<p>&gt;&gt;&gt; digits</p>@<p>[‘thumb’, ‘pointer’, ‘middle’, ‘ring’, ‘pinky’]</p>@<p>&gt;&gt;&gt; from string import *</p>@<p>&gt;&gt;&gt; digits</p>@<p>‘0123456789’</p></td>@</tr>@</tbody>@</table><S-CR>Sometimes it makes sense to use “star notation” when you’re importing@only one outside library and using its tools exclusively. This is often@the case when you are working with GUIs because all the components you@need are included in the imported module – there almost no chance of@namespace collisions, even when you’re part of a collaborative effort.<S-CR>File System Based Namespaces@----------------------------<S-CR>Python has the ability to use the file system to create namespaces for@modules and it works just like what we’ve seen for ordinary objects.@Building packages is beyond the scope of this course, but for now know@that you can have a directory structure like:<S-CR>main\_application\\<S-CR>\_\_init\_\_.py<S-CR>subdir\_1\\<S-CR>\_\_init\_\_.py<S-CR>module.py<S-CR>subdir\_2\\<S-CR>\_\_init\_\_.py<S-CR>module.py<S-CR>If main\_application can be discovered by your app, then you can go:<S-CR>\>\>\> from main\_application import subdir\_1, subdir\_2<S-CR>… which gives you access to subdir\_1.module and subdir\_2.module. The@two identically-named module names are each tucked in behind their@directory name and will not present namespace conflicts in your app.<S-CR>On a related note, what makes main\_application discoverable by Python?@When you import a module, Python looks at the contents of **sys.path** –@an ordered list of all the directories on its search path. It’s@comprised of normal, default locations and whatever might be in your@PYTHONPATH environment variable. The element, and the first place the@interpreter looks, is in your current working directory. What this means@– and this has caught many an unwary programmer – is that if you name@your module the same as a system package, then when you try to import a@Python module you will get your own instead. Then you will go insane@trying to figure out why your imported module doesn’t work as expected.<S-CR>As a result, you’ll want to be a little careful about choosing names. If@you’re considering ‘string.py’, for instance, you might first want to@attempt to **import** **string**. If the operation succeeds, ‘string.py’@is already taken, if your get an **ImportError** then you’re safe. For@now. Bear in mind that installation of new packages or editing the@PYTHONPATH can change things.<S-CR>As you’ll see, the libraries available in Python’s standard library and@general ecosystem provide highly-leveraged ways to extend the@already-powerful capabilities. Let’s look at some ways to do effective@“time management.”<S-CR>Time-related Objects: time, datetime, and calendar@--------------------------------------------------<S-CR>Since we’re on the topic of using imported libraries, let’s take a look@at Python’s three principle libraries providing dealing with time. Each@has its own strengths, weaknesses and capabilities. We’ll go through@some of the capabilities of each here.<S-CR>Before we jump in, there are some things to be aware of:<S-CR>-   Computers “think” of time in terms of the elapsed seconds since an@    agreed-upon point in time called an “epoch.” For most POSIX@    (Linux-like) systems, the epoch began on January 1, 1970. For@    Windows, it’s January 1, 1601[47]. Typically, this won’t matter@    because Python is OS-agnostic.<S-CR>-   Since different parts of the world are in different time zones, we@    often think of what time it is in Greenwich (London), England. This@    is known by various names such as GMT, UTC and Zulu.<S-CR>-   However, your computer (or AWS slice, or server) may “think” in@    local time. Local time is a little weird. Time zones can shift@    because of local decisions. Daylight savings time can vary@    county-by-county, and state-by-state. “Summer time” in Europe and@    elsewhere doesn’t necessarily synch with U.S. daylight savings time.@    UTC is reliable.<S-CR>-   There are two “flavors” of elapsed time available. One is told by@    the clock on your wall – it’s an objective measure of the time you@    experience. The other is the elapsed time the CPU works on your@    program. You’ll want to be sure of which you’re using when it’s@    material (such as when your application is running on a busy machine@    the clock time isn’t a great measure of how efficient your program@    is.<S-CR>Time Objects@------------<S-CR>Here are a few lines of code that use some of the basic functionality of@time. This code grabs both the clock time and CPU time and demonstrates@use of the **sleep** method. You’ll note that these are reported to@different levels of precision and produce slightly different results.@**time**.**clock** reports how long this script has been running while@**time**.**time** reports the number of seconds that have elapsed since@the dawn of time.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_time.py</p>@<p>import time</p>@<p>print(time.clock(), time.time())</p>@<p>time.sleep(1) #seconds</p>@<p>print(time.clock(), time.time())</p>@<p>#results:</p>@<p>#7.602588377238914e-07 1475008594.969013</p>@<p>#1.0000152051767546 1475008595.96914</p></td>@</tr>@</tbody>@</table><S-CR> Datetime Objects@----------------<S-CR>For most purposes, you’ll be working with **datetime** objects provided@from the library of the same name. A **datetime** object is a fairly@easy-to-read tuple-like structure, and it’s straightforward to extract@information. Here’s an example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_time_1.py</p>@<p>from datetime import datetime</p>@<p>d = datetime.now()</p>@<p>print(d)</p>@<p>print("the hour is: {}\n.”.format(d.hour))</p>@<p>print("the year is: {}\n.”.format(d.year))</p>@<p>#result (of course, yours will vary)</p>@<p>#2016-09-27 14:01:15.357498</p>@<p>#the hour is: 14</p>@<p>#the year is: 2016</p></td>@</tr>@</tbody>@</table><S-CR>The **datetime** object has built in functionality to do things like@differences in time, report in terms of different time zones, etc. [48]<S-CR>Here are some examples:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_time_2.py</p>@<p>from datetime import datetime, timezone</p>@<p>now_here = datetime.now()</p>@<p>print("Now, this timezone: ", now_here)</p>@<p>now_uk = datetime.now(timezone.utc)</p>@<p>print("Now, in England: ", now_uk)</p>@<p>the_date = now_uk</p>@<p>print("Days since 01-01-0001: ", the_date.toordinal())</p>@<p>epoch = datetime(1970,1,1, tzinfo = timezone.utc)</p>@<p>print("01/01/1970 timestamp : ", epoch.timestamp())</p>@<p>print("Now in English timestamp: ", now_uk.timestamp())</p>@<p>delta = now_uk - epoch</p>@<p>print("Time delta in seconds: ", delta.total_seconds())</p></td>@</tr>@</tbody>@</table><S-CR>If you run this code, you’ll get something like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Now, in England: 2016-09-30 00:17:07.847688+00:00</p>@<p>Days since 01-01-0001: 736237</p>@<p>01/01/1970 timestamp: 0.0</p>@<p>Now in English timestamp: 1475194627.847688</p>@<p>Time delta in seconds: 1475194627.847688</p></td>@</tr>@</tbody>@</table><S-CR>For all its charms, **datetime** produces fairly ugly output, left to@its own devices. Fortunately, there’s an easy way to customize is using@the “string from time” functionality, known as **strftime**[49]. The@basic syntax is:<S-CR>\<datetime object\>.strftime(\<format string\>)<S-CR>A simple example might be:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_time_3.py</p>@<p>from datetime import datetime</p>@<p>date_format = "%d, %b %Y"</p>@<p>now = datetime.now()</p>@<p>print("Hello! Today is {}..” \</p>@<p>.format(now.strftime(date_format)))</p>@<p>#result:</p>@<p>Hello! Today is 27, Sep 2016.</p></td>@</tr>@</tbody>@</table><S-CR>If you want, you can include other characters in the format string. In@the next example, we provide punctuation (“:” and “-“ characters) to@make something like we’d see in a log file (easy to sort@chronologically).<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_time_4.py</p>@<p>from datetime import datetime</p>@<p>now = datetime.now()</p>@<p>exact_format = "%Y-%m-%d %H:%M"</p>@<p>print("Or, more precisely, {}." \</p>@<p>.format(now.strftime(exact_format)))</p>@<p>#result</p>@<p>Or, more precisely, 2016-09-27 14:26.</p></td>@</tr>@</tbody>@</table><S-CR>There are many formatting strings available. You can download a “cheat@sheet”[50] in the likely event you don’t want to memorize them; some of@the more useful codes appear below:<S-CR><table>@<tbody>@<tr class="odd">@<td><table>@<thead>@<tr class="header">@<th><strong><span class="underline">Code</span></strong></th>@<th><strong><span class="underline">Meaning</span></strong></th>@<th><strong><span class="underline">Example</span></strong></th>@</tr>@</thead>@<tbody>@<tr class="odd">@<td>%a</td>@<td>Weekday as locale’s abbreviated name.</td>@<td>Mon</td>@</tr>@<tr class="even">@<td>%A</td>@<td>Weekday as locale’s full name.</td>@<td>Monday</td>@</tr>@<tr class="odd">@<td>%B</td>@<td>Month as locale’s full name.</td>@<td>September</td>@</tr>@<tr class="even">@<td>%m</td>@<td>Month as a zero-padded decimal number.</td>@<td>9</td>@</tr>@<tr class="odd">@<td>%y</td>@<td>Year without century as a zero-padded decimal number.</td>@<td>13</td>@</tr>@<tr class="even">@<td>%Y</td>@<td>Year with century as a decimal number.</td>@<td>2013</td>@</tr>@<tr class="odd">@<td>%p</td>@<td>Locale’s equivalent of either AM or PM.</td>@<td>AM</td>@</tr>@<tr class="even">@<td>%x</td>@<td>Locale’s appropriate date representation.</td>@<td>9/30/2013</td>@</tr>@<tr class="odd">@<td>%X</td>@<td>Locale’s appropriate time representation.</td>@<td>7:06:05</td>@</tr>@<tr class="even">@<td>%%</td>@<td>A literal ‘%’ character.</td>@<td>%</td>@</tr>@</tbody>@</table></td>@</tr>@</tbody>@</table><S-CR>Working with Calendar@---------------------<S-CR>Python also has a time-related function that knows how to print@nicely-formatted calendars, figure out the day of week, keep track of@leap days, etc.[51] Here’s a brief flyover of some of its@capabilities[52].<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_calendar.py</p>@<p>import calendar</p>@<p>#create a TextCalendar instance</p>@<p>cal = calendar.TextCalendar()</p>@<p>print("We just produced a {}.\n.”.format(type(cal)))</p>@<p>print("Let’s check out the calendar for April, 2016\n")</p>@<p>#note that we don’t need to call print() –</p>@<p># it’s baked into prmonth()</p>@<p>calendar.prmonth(2016,4)</p>@<p>print()</p>@<p>#what day of the week was I born?</p>@<p>birthday_year = 1957</p>@<p>birthday_month = 5</p>@<p>birthday_day = 10</p>@<p>birthday_day_of_week = calendar.weekday(birthday_year,</p>@<p>birthday_month,</p>@<p>birthday_day)</p>@<p>birthday_dict = {0:’Mon’, 1:’Tue’, 2:’Wed’,</p>@<p>3:’Thur’, 4:’Fri’, 5:’Sat’, 6:’Sun’}</p>@<p>print("I was born on a {}.”\</p>@<p>.format(birthday_dict[birthday_day_of_week]))</p></td>@</tr>@</tbody>@</table><S-CR>If you run this code, you’ll find out that the author arrived just in@time for the weekend a long, long time ago (but you might try it for@your own birthday):<S-CR><table>@<tbody>@<tr class="odd">@<td><p>We just produced a &lt;class ‘calendar.TextCalendar’&gt;.</p>@<p>Let’s check out the calendar for April, 2016.</p>@<p>April 2016</p>@<p>Mo Tu We Th Fr Sa Su</p>@<p>1 2 3</p>@<p>4 5 6 7 8 9 10</p>@<p>11 12 13 14 15 16 17</p>@<p>18 19 20 21 22 23 24</p>@<p>25 26 27 28 29 30</p>@<p>I was born on a Fri!</p></td>@</tr>@</tbody>@</table><S-CR>Introduction to Python’s “Middleware” Libraries@-----------------------------------------------<S-CR>In the spirit of continuing a discussion of adding capability beyond@Python’s core repertoire, we might consider some of Python’s built-in@modules **sys** and **os**. We’ll discuss their basic contributions@here. I would encourage you to explore these on your own using **dir**@and **help** as your investigation tools.<S-CR>-   The **sys** module contains information about the particular Python@    installation you’re working with and how it’s installed on your@    local OS. This is where **sys.path** (the **list** of directories@    the interpreter uses to find imported modules).<S-CR>The **os** module contains a large repertoire of “middleware” that@operates between Python and your local OS. It keeps track of things like@the correct path separator to use.<S-CR>Here are a couple examples from my systems. This is what I get from a@Windows box:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Python 3.4.1 (v3.4.1:c0e311e010fc, May 18 2014, 10:45:13) [MSC v.1600 64 bit (AMD64)] on win32</p>@<p>Type "help", "copyright", "credits" or "license" for more information.</p>@<p>&gt;&gt;&gt; import os</p>@<p>&gt;&gt;&gt; os.name</p>@<p>‘nt’</p>@<p>&gt;&gt;&gt; os.path.sep</p>@<p>‘\\’</p>@<p>&gt;&gt;&gt; os.path.join(‘path’,’to’, ‘file’)</p>@<p>‘path\\to\\file’</p>@<p>&gt;&gt;&gt;</p></td>@</tr>@</tbody>@</table><S-CR>And this is the same information from one of my Linux virtuals:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Python 3.3.0 (default, Sep 5 2016, 11:33:57)</p>@<p>[GCC 4.8.4] on linux</p>@<p>Type "help", "copyright", "credits" or "license" for more information.</p>@<p>&gt;&gt;&gt; import os</p>@<p>&gt;&gt;&gt; os.name</p>@<p>‘posix’</p>@<p>&gt;&gt;&gt; os.path.sep</p>@<p>‘/’</p>@<p>&gt;&gt;&gt; os.path.join(‘path’, ‘to’, ‘file’)</p>@<p>‘path/to/file’</p></td>@</tr>@</tbody>@</table><S-CR>The tools in **os** are really important if you want to maximize the@portability of your code from platform-to-platform. The last thing you@want to do is put in conditional statements to do things like construct@file paths[53]. Or – worse yet – having your code work only on the@“flavor” of development platform you’re using.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercises:</p>@<ul>@<li><p>Starting with a text representation of your birthday e.g., “May 5, 1970” please create a routine that produces a report describing how long you’ve been alive (to the nearest day) and what day of the week you were born.</p></li>@<li><p>Print out a calendar showing the month you were born <span class="underline">without</span> using the built in <strong>TextCalendar</strong> tool. You might consider using methods like <strong>calendar.weekday</strong> and <strong>calendar.monthrange</strong> to help out.</p></li>@</ul>@<blockquote>@<p>You might use a list of lists to create a month. Each internal list object might hold week. The tricky part here is to get the first week right. If the first falls on a Wednesday, say, you’ll want to “pad out” the first few elements with blanks before assigning “1” to the Wednesday slot.</p>@<p>Feel free to use any of the other tools you find in <strong>calendar</strong> to help out.</p>@</blockquote></td>@</tr>@</tbody>@</table><S-CR>Exceptions@==========<S-CR>Things sometimes don’t go as planned – especially when you’re dealing@with user input, content captured “from the wild”, or integrating code@written by others into your own. In these situations you need a way to@gracefully handle surprises without crashing your code.<S-CR>Sometimes things do go as expected and you want to set up “sentinels” to@identify specific, anticipated situations and act accordingly.<S-CR>You’ll find Python’s built-in exceptions model to be useful in both of@these situations. This chapter will explore how you can put it to use.<S-CR>Basic Usage@-----------<S-CR>­The easiest form of an exception is the **assert** statement. Its@syntax is pretty easy:<S-CR>assert \<some statement\><S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; assert True #nothing happens</p>@<p>&gt;&gt;&gt; assert False</p>@<p>Traceback (most recent call last):</p>@<p>File "&lt;stdin&gt;", line 1, in &lt;module&gt;</p>@<p>AssertionError</p></td>@</tr>@</tbody>@</table><S-CR>As you can see, the interpreter generates an **AssertionError** (which@is a type of exception) when statement evaluated is **False**. This sort@of a blunt approach that doesn’t yield much actionable information, but@it is a “quick and dirty” way to identify a problem during execution.<S-CR>As this stands, finding a **False** condition basically crashes your@program – something you usually don’t want to happen. So how can you@handle this more smoothly? You can tell the interpreter what to do in@specific circumstances using a **try** / **except** block. Here’s how:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_except.py</p>@<p>try:</p>@<p>assert False</p>@<p>except AssertionError:</p>@<p>print("Sorry, pal")</p>@<p>print("I’m gonna keep running.")</p>@<p>#result:</p>@<p>#Sorry, pal</p>@<p>#I’m gonna keep running.</p></td>@</tr>@</tbody>@</table><S-CR>Much better, right? The general form of a try/except block is:<S-CR>try:<S-CR>\<an indented suite of statements\><S-CR>except \<some exception\>:<S-CR>\<an indented suite of statements \><S-CR>except \<some exception\>:<S-CR>\<an indented suite of statements \><S-CR>finally:<S-CR>\<an indented suite of statements\><S-CR>Multiple Exceptions@-------------------<S-CR>You can “stack” exceptions handled much like **elif** statements in an@**if**..**then**..**else** block. Exception handling stops at the first@one found. The **finally** block gets executed no matter what.<S-CR>Here’s an example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_except_1.py</p>@<p>def bad_int():</p>@<p>int(‘a’)</p>@<p>def bad_not_defined():</p>@<p>int(a)</p>@<p>def bad_div():</p>@<p>1/0</p>@<p>def good():</p>@<p>print("Hi!")</p>@<p>for func in (bad_int, bad_not_defined, bad_div, good):</p>@<p>try:</p>@<p>func()</p>@<p>except ValueError:</p>@<p>print("you have no values")</p>@<p>except TypeError:</p>@<p>print("Learn how to type")</p>@<p>except NameError:</p>@<p>print("You have a horse with no name")</p>@<p>except ZeroDivisionError:</p>@<p>pass</p>@<p>finally:</p>@<p>print("I’m done.\n")</p></td>@</tr>@</tbody>@</table><S-CR>The output is shown below so you can see how the interpreter stepped@through the various issues presented to it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>you have no values</p>@<p>I’m done.</p>@<p>You have a horse with no name</p>@<p>I’m done.</p>@<p>I’m done.</p>@<p>Hi!</p>@<p>I’m done.</p></td>@</tr>@</tbody>@</table><S-CR>One important point to note here is that, like an **if .. elif ..elif**@stack of code only one exception handler’s indented suite can be@executed. The implication is that you want to catch the most general@exceptions at the top of the stack and the most general ones at the@bottom. More on this in a moment, but it’s an important design@consideration.<S-CR>The Exception Class@-------------------<S-CR>In Python, exceptions are all derived from the same parent (called@**Exception**) and specified to handle individual problems[54]. This@presents the possibility to create your own if none of the built-in ones@fit. Here’s how you might create simple custom exception and a more@elaborate one to handle the potentially-serious Wombat condition:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_except_2.py</p>@<p>#a minimal custom exception</p>@<p>class MinimalException(Exception):</p>@<p>pass</p>@<p>class WombatException(Exception):</p>@<p>def __str__(self):</p>@<p>return("Wombat!")</p>@<p>def wombat():</p>@<p>raise WombatException</p>@<p>wombat()</p>@<p>#result</p>@<p>#__main__.WombatException: Wombat!</p></td>@</tr>@</tbody>@</table><S-CR>We’ll get into classes later in the course. For now, know that we took a@**class** object already part of the language, inherited from, and@redefined part of it.<S-CR>Because all exceptions are inherited from the same parent, there’s a@complex “family tree” of available ones. Here’s part of it:<S-CR>+-- BaseException<S-CR>+-- Exception<S-CR>+-- StopIteration<S-CR>+-- StopAsyncIteration<S-CR>+-- ArithmeticError<S-CR>\| +-- FloatingPointError<S-CR>\| +-- OverflowError<S-CR>\| +-- ZeroDivisionError<S-CR>You don’t need an encyclopedic understanding of all this but it’s@important to know that the interpreter will catch exceptions closest to@the “root” of the family tree. To put it another way, if you have a line@of code like this:<S-CR>|                         |@|-------------------------|@| except ArithmeticError: |<S-CR>… it will catch the **FloatingPointError**, **OverFlowError**, and@**ZeroDivisionError**. If you do this:<S-CR>|                   |@|-------------------|@| except Exception: |<S-CR>… it will catch any exception.<S-CR>Python has many built-in exception types that handle specific problems@encountered during execution. Some of the more common ones include:<S-CR>-   **KeyboardInterrupt** (the user hits cntl-c)<S-CR>-   **TypeError** (the wrong type of object was provided)<S-CR>-   **ValueError** (an invalid argument was supplied)<S-CR>The entire “family tree” of exceptions is in the official docs[55] and@could make a valuable addition to your personal library.<S-CR>Miscellaneous@-------------<S-CR>If you want to capture the message that normally comes with the@exception in your own **except** clause, you can create a handle to it@and print it out. You can also print out the call stack and specific@lines of code that caused the problem (what you normally get when you@make a mistake at the keyboard) using **traceback**.<S-CR>Also, you can ask the interpreter to pass handling of the exception to a@handler higher up in the call stack (one of the routines that called@your current routine) with the keyword **raise**. If that error was@handled higher up, it will be handled there. Here’s an example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_except_3.py</p>@<p>import traceback</p>@<p>def another_bad_int():</p>@<p>try:</p>@<p>int(‘b’)</p>@<p>except:</p>@<p>raise</p>@<p>for func in (another_bad_int, ):</p>@<p>try:</p>@<p>func()</p>@<p>except ValueError as ve:</p>@<p>print("you have no values\n\n", ve, "\n")</p>@<p>traceback.print_stack()</p>@<p>raise</p></td>@</tr>@</tbody>@</table><S-CR>Here, we set up a handler in the for block – a fancier one this time@because we have named our error handler “ve” and printed it out. We also@have chosen one of the methods of the **traceback** module to give@detailed information about the source of the problem[56].<S-CR>Note that the function **another\_bad\_int** does not have any of the@handling logic. If a problem is detected there, it “passes the buck” to@the handler we just set up[57].<S-CR>Here’s what the more refined output will look like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>you have no values</p>@<p>invalid literal for int() with base 10: ‘b’</p>@<p>File "C:\Program Files (x86)\Wing IDE 5.0\</p>@<p>bin\wingdb.py", line 10, in &lt;module&gt;</p>@<p>"""</p>@<p>File "C:\Program Files (x86)\Wing IDE</p>@<p>5.0\bin\wingdb.py", line 605, in main</p>@<p>def main():</p>@<p>&lt;snip&gt;</p>@<p>File c:\Users\pbarton\Desktop\_kirby_python\</p>@<p>py_except_3.py",</p>@<p>line 15, in &lt;module&gt;</p>@<p>traceback.print_stack()</p></td>@</tr>@</tbody>@</table><S-CR>Strategies@----------<S-CR>-   You want to get a good match between the exception(s) you looking@    for and the exceptions you’re handling. Make the **except**@    statements as narrow as possible (furthest out on the branch of the@    “family tree” as possible).<S-CR>-   Know what you’re looking for and why. You can try to break it at the@    keyboard first to figure out what could go wrong.<S-CR>-   Keep it “local” – check a line or two at a time.<S-CR>-   Worst case scenario:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>try:</p>@<p>&lt;1,000 lines of code you don’t understand&gt;</p>@<p>except Exception:</p>@<p>pass</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise:</p>@<ul>@<li><p>Create a custom exception that reports a problem when an integer is unexpectedly encountered, but otherwise fails silently.</p></li>@<li><p>Create a second exception that reports a problem when a complex number is unexpectedly encountered and prints out a polite message.</p></li>@<li><p>Create a function that requests that the user input a number. If the number is a floating point type, return its square. Otherwise raise the appropriate exception.</p></li>@</ul></td>@</tr>@</tbody>@</table><S-CR>Input and Output@================<S-CR>So far, we’ve been working with programs and data that exist only in@memory. This is fine unless you want the information produced to persist@between sessions. To accomplish this, you’ll want to learn how to store@information in files of some type. These could be text files, databases,@or (if you want to store intact objects) **JSON**, **pickle**, or@**shelve** files.<S-CR>To accomplish any of these we need to establish a pipe to move@information to another system resource and the necessary system object@to receive it. Let’s start with simple file object and the built-in@**open** directive. The syntax is:<S-CR>\<file handle name\> = open(\<file name\>, \<mode\>)<S-CR>Basic File i/o@--------------<S-CR>To open a new file and establish a handle to it, we can go:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; f = open(‘afile’, ‘w’)</p>@<p>&gt;&gt;&gt; f</p>@<p>&lt;_io.TextIOWrapper name = ‘afile’ mode = ‘w’ encoding = ‘UTF-8’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>This creates a file called ‘afile’ in the write only mode. If another@file of the same name already exists it will get overwritten silently,@so be careful.<S-CR>Once the file is open, we can write something to it using the file@handle’s **write** method. When done we can execute the **close**@method.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; f.write("Hello, afile")</p>@<p>12</p>@<p>&gt;&gt;&gt; f.close()</p></td>@</tr>@</tbody>@</table><S-CR>Reading a file is equally straightforward. The only difference is that@we’ll want to use some variant of the ‘r’ mode[58]. If you open a file@for reading, Python expects the file to exist. If it doesn’t you’ll get@a **FileNotFoundError**.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; f = open(‘afile’, ‘r’)</p>@<p>&gt;&gt;&gt; f.read()</p>@<p>‘Hello, afile’</p>@<p>&gt;&gt;&gt; f.close()</p></td>@</tr>@</tbody>@</table><S-CR>We can use the file handle object to tell us about the file. This code@sample shows you some of the things you can learn.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_files_1.py</p>@<p>f = open(‘afile’, ‘w’)</p>@<p>f.write("Hello afile!")</p>@<p>print("What’s up with {}?\n.”.format(f.name))</p>@<p>print("readable?", f.readable())</p>@<p>print("writable?", f.writable())</p>@<p>print("encoding:", f.encoding)</p>@<p>print("closed?", f.closed)</p>@<p>print("Closing Now!")</p>@<p>f.close()</p>@<p>print("closed?", f.closed)</p>@<p>#results</p>@<p>#What’s up with afile?</p>@<p>#readable? False</p>@<p>#writable? True</p>@<p>#encoding: cp1252</p>@<p>#closed? False</p>@<p>#Closing Now!</p>@<p>#closed? True</p></td>@</tr>@</tbody>@</table><S-CR>There are different modes for opening text files. Besides read “r” and@write, “w” you can open it an append mode “a.” This allows you to open a@file for writing without destroying any existing file. Instead, any new@write operations add material to the end. If you include a “+” with any@of these, you get both read and write access.<S-CR>The modes we’ve seen so far are for text files – these all involve some@sort of encoding operation to convert human-readable characters to raw@bytes. If the file is storing binary data, you have to let the compiler@know by using a “b directive.” These take the form “r+b”, “w+b” and@“a+b.” For instance, you can go:<S-CR>|                                  |@|----------------------------------|@| \>\>\> f = open (‘junk2’, ‘w+b’) |<S-CR> Creating a Context@------------------<S-CR>In the examples above, we closed the files when done with them. This is@considered a best practice because, although Python’s built in garbage@collection will probably take care of things, it works on its own@schedule. Some operating systems (Windows) have a limit on the number of@open files you’re allowed, and with large applications – like file-based@database systems you could get into trouble.<S-CR>An easier way to handle closing files IMHO is to create a context using@the **with** keyword. A context is like a temporary sandbox for a block@of code to run in. When the code is done, the context is automatically@terminated and all the objects are eligible for garbage collection.@Here’s how you might use it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; with open(‘junk2’, ‘w’) as f:</p>@<p>f.write(‘hey there junk2’)</p>@<p>&gt;&gt;&gt; f</p>@<p>&lt;closed file ‘junk2’, mode ‘w’ at 0x7fc159b596f0&gt;</p></td>@</tr>@</tbody>@</table><S-CR> File Pointers@-------------<S-CR>Internally the file has a pointer – sort of like a sticky note – to tell@it what line it’s on. When you **open** a file in a read or write mode,@the pointer starts at the top. If it’s open in the append mode, the@pointer starts at the bottom.<S-CR>You can move the file pointer around using the file handler’s **seek**@method, invoked with a single argument for the position you want to move@it. Here’s an example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; f = open(‘afile’, ‘a+’)</p>@<p>&gt;&gt;&gt; f.read()</p>@<p>‘‘</p>@<p>&gt;&gt;&gt; f.seek(0)</p>@<p>0</p>@<p>&gt;&gt;&gt; f.read()</p>@<p>‘Hello, afile’</p>@<p>&gt;&gt;&gt; f.seek(6)</p>@<p>6</p>@<p>&gt;&gt;&gt; f.read()</p>@<p>‘ afile’</p>@<p>&gt;&gt;&gt; f.tell()</p>@<p>12</p>@<p>&gt;&gt;&gt; f.seek(0)</p>@<p>0</p>@<p>&gt;&gt;&gt; f.tell()</p>@<p>0</p></td>@</tr>@</tbody>@</table><S-CR>You’ll note that the first time we read it, nothing was reported. That’s@because the file pointer was already at end of the file. With seek we@put the pointer to the top of the file and **read** performed as@expected. The **tell** method simply reports the position of the@pointer. Here we’re verifying that **seek** did its job.<S-CR>I would point out that using **seek** against a text file is a dicey@proposition – unless you’re simply going to the top. The reason is that@the width of a binary character is predictable but the width of a@character is not. If it's only the bottom half of ASCII, the characters@are one byte long, but you never know. This all depends on the encoding.@For instance, the ubiquitous UTF -8 can hold all 1MM + Unicode code@points, but individual characters only consume the required "space" –@anywhere from one to four 8-bit bytes.<S-CR> Working with the File System@----------------------------<S-CR>The easiest way to work with the file system is to use the **os**@library[59]. Here is where you can find all sorts of tools that you@might use at the command line of a shell program. We’ll use the@following example to take some of the methods for a spin around the@block while exploring your file system and the repertoire of the@library.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_files_2.py</p>@<p>import os</p>@<p>import tempfile</p>@<p>#get the name of the current directory</p>@<p>original_dir = os.getcwd()</p>@<p>print(‘we started in’)</p>@<p>print(original_dir)</p>@<p>#go to the parent directory</p>@<p>os.chdir(‘..’)</p>@<p>print("\nnow we’re in")</p>@<p>print(os.getcwd())</p>@<p>#get the original directory contents</p>@<p>dir_contents = os.listdir(original_dir)</p>@<p>#classify the first few objects</p>@<p>print("\nexamining the contents of {}.” \</p>@<p>.format(original_dir))</p>@<p>for _ in range(5):</p>@<p>fs_object_name = dir_contents.pop()</p>@<p>fs_object = os.path.join(original_dir, fs_object_name)</p>@<p>label = ‘‘</p>@<p>if os.path.isdir(fs_object):</p>@<p>label = ‘dir’</p>@<p>if os.path.isfile(fs_object):</p>@<p>label = ‘file’</p>@<p>if os.path.islink(fs_object):</p>@<p>label = ‘link’</p>@<p>print(label, fs_object_name)</p>@<p>#checking for a directory, creating if it’s not there</p>@<p>look_for = ‘junk’</p>@<p>look_in = original_dir</p>@<p>print("\nIf you don’t have a junk directory, \</p>@<p>let’s make one\n")</p>@<p>if not os.path.exists(os.path.join(look_in,</p>@<p>look_for)):</p>@<p>os.mkdir(os.path.join(look_in, look_for))</p>@<p>#another way, using exceptions</p>@<p>try:</p>@<p>os.mkdir(os.path.join(look_in, look_for))</p>@<p>except:</p>@<p>pass</p>@<p>#print out the methods in the os module</p>@<p>print("\nGee, lookee at all the stuff we can \</p>@<p>do with os!\n")</p>@<p>for obj in dir(os):</p>@<p>first_char = obj[0]</p>@<p>#filter out the internal methods and CONSTANTS</p>@<p>if not first_char = = "_" and not first_char.isupper():</p>@<p>print(obj)</p></td>@</tr>@</tbody>@</table><S-CR>File Metadata@-------------<S-CR>You can retrieve file metadata using the **os.stat** method.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; meta = os.stat(‘junk2’)</p>@<p>&gt;&gt;&gt; meta</p>@<p>os.stat_result(</p>@<p>st_mode = 33206, st_ino = 24206847997486860,</p>@<p>st_dev = 3193733530, st_nlink = 1, st_uid = 0, st_gid = 0,</p>@<p>st_size = 0, st_atime = 1475253311, st_mtime = 1475253311,</p>@<p>st_ctime = 1475253311)</p></td>@</tr>@</tbody>@</table><S-CR>The output is pretty horrible to look at, and poorly-labeled, but here’s@a list of a few of the ones you’ll need most:<S-CR>st\_ctime time of creation<S-CR>st\_gid group ID of owner<S-CR>st\_mode protection bits<S-CR>st\_mtime time of last modification<S-CR>st\_size total size, in bytes<S-CR>st\_uid user ID of owner<S-CR>You can access an individual element using its index or name. For@instance, if you wanted the file size you could go:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; meta.st_size</p>@<p>15</p>@<p>&gt;&gt;&gt; meta[6]</p>@<p>15</p></td>@</tr>@</tbody>@</table><S-CR>Serializing Objects@-------------------<S-CR>Python supports object serialization with a couple libraries called@**json**[60] and **pickle.** Both do roughly the same thing in that they@can encode and decode intact objects like functions and classes into a@form that can be saved to the hard drive. The **pickle** methods work in@byte streams while the **json** methods work in plain text.<S-CR>Why would you want to work with bytes? For one thing, you can store your@code very compactly. More importantly, you can stream byte code between@applications or computers whereas you can’t do that with Python objects.<S-CR>Another advantage is that serialized data is in a very predictable@format. That makes life very easy on the interpreter. Let’s say you have@a huge data file that you read into a Python array for processing. If@the file starts out life as a comma-delimited file, say, reading it is@expensive because the interpreter has to figure out how large every@piece is, convert it to a numeric data type, and put it into memory.<S-CR>If, on the other hand, the interpreter knows the geometry of the data@and can “mechanically” ingest the pieces of it, very little processing@has to happen – it just needs to be loaded into memory.<S-CR>In my experience a 2MB, csv-formatted file takes around 30 seconds to@load on a decent laptop; a serialized version takes only about 0.5@seconds. Your mileage may vary, but you can bet on seeing some real@performance differences[61].<S-CR>So how do we work this magic? Let’s find out.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_files_3.py</p>@<p>"""quite a pickle"""</p>@<p>import pickle</p>@<p>#make an object</p>@<p>obj = [ [1, 2, 3],</p>@<p>[4, 5, 5],</p>@<p>[7, 8, 9]</p>@<p>]</p>@<p>print("hey, we’ve got an object")</p>@<p>print(obj)</p>@<p>#open a binary file (remember, we’re writing bytes)</p>@<p>pickle_file = "brine"</p>@<p>with open(pickle_file, ‘wb’) as f:</p>@<p>pickle.dump(obj, f)</p>@<p>#let’s kill the object to prove this works</p>@<p>obj = None</p>@<p>if not obj:</p>@<p>print("\nno object here!")</p>@<p>with open(pickle_file, ‘rb’) as f:</p>@<p>recovered_obj = pickle.load(f)</p>@<p>#now, take a look</p>@<p>print("\nPresto, chango, here’s our recovered object!")</p>@<p>print(recovered_obj)</p></td>@</tr>@</tbody>@</table><S-CR>Here are the results:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>hey, we’ve got an object</p>@<p>[[1, 2, 3], [4, 5, 5], [7, 8, 9]]</p>@<p>no object here!</p>@<p>Presto, chango, here’s our recovered object!</p>@<p>[[1, 2, 3], [4, 5, 5], [7, 8, 9]]</p></td>@</tr>@</tbody>@</table><S-CR>You can **pickle** multiple objects, but you have to do so individually.@Here’s how you might do it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_files_4.py</p>@<p>"""quite a crowed pickle barrel"""</p>@<p>import pickle</p>@<p>#make a couple objects</p>@<p>obj = [ [1, 2, 3],</p>@<p>[4, 5, 5],</p>@<p>[7, 8, 9]</p>@<p>]</p>@<p>obj1 = "howdy doody"</p>@<p>obj2 = set([33,43,53])</p>@<p>#open a binary file (remember, we’re writing bytes)</p>@<p>pickle_file = "spicy"</p>@<p>with open(pickle_file, ‘wb’) as f:</p>@<p>pickle.dump(obj, f)</p>@<p>pickle.dump(obj1, f)</p>@<p>pickle.dump(obj2, f)</p>@<p>#let’s kill the objects to prove this works</p>@<p>obj = None; obj1 = None; ojb2 = None # not recommended</p>@<p>with open(pickle_file, ‘rb’) as f:</p>@<p>recovered_obj = pickle.load(f)</p>@<p>recovered_obj1 = pickle.load(f)</p>@<p>recovered_obj2 = pickle.load(f)</p>@<p>#now, take a look</p>@<p>print("our objects survived!")</p>@<p>print(recovered_obj)</p>@<p>print(recovered_obj1)</p>@<p>print(recovered_obj2)</p></td>@</tr>@</tbody>@</table><S-CR>While this works, sometimes it’s more convenient to organize objects to@be pickled in a **dict** object – this makes tracking them much easier.@Here is how you might apply this strategy while potentially positioning@ourselves for a really big mistake. Can you spot it?<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_files_5.py</p>@<p>import pickle as pickle</p>@<p>from junk import JUNK</p>@<p>pickle_file="dill"</p>@<p>#make a couple objects</p>@<p>obj = [ [1, 2, 3],</p>@<p>[4, 5, 5],</p>@<p>[7, 8, 9]</p>@<p>]</p>@<p>obj1="howdy doody"</p>@<p>obj2=set([33,43,53])</p>@<p>#another (better) way:</p>@<p>to_pickle={'obj' : obj,</p>@<p>'obj1': obj1,</p>@<p>'obj2': obj2,</p>@<p>'junk': JUNK</p>@<p>}</p>@<p>with open(pickle_file, 'wb') as f:</p>@<p>pickle.dump(to_pickle,f)</p>@<p>to_pickle=None</p>@<p>with open(pickle_file, 'rb') as f:</p>@<p>to_pickle=pickle.load(f)</p></td>@</tr>@</tbody>@</table><S-CR>The “big mistake” here involves the inclusion of JUNK in our file system@object. The issue is that it’s a value imported from another routine.@Safe enough if working alone, I imagine, but what if junk.py were being@maintained by another team working long and hard on perfecting the@value? Today it might be 777, but what if later it were refined to@become 888? Our persistent object would have stale information and we@might never know it. In fact, the pickle file does not even a path back@to find where 777 came from in the first place. We certainly won’t get@warnings or error messages. Anyway, you can do this, but be careful.<S-CR>Pickle Caveats@--------------<S-CR>You can’t **pickle** everything. The objects have to be discrete and@available globally to the module. Here’s what can be pickled, strait@from the docs[62]:<S-CR>-   **None**, **True**, and **False**<S-CR>-   integers, long integers, floating point numbers, complex numbers<S-CR>-   normal and Unicode strings<S-CR>-   **tuples**, **lists**, **sets**, and dictionaries containing only@    picklable objects<S-CR>-   functions defined at the top level of a module<S-CR>-   built-in functions defined at the top level of a module<S-CR>-   **class** objects that are defined at the top level of a module<S-CR>**pickle** is a Python-specific tool – pickled objects can’t be@deserialized on other platforms. If this is a concern, consider using@**JSON**. You don’t get the efficiency of a serialized object, but it’s@pretty close to Esperanto.<S-CR>Finally, since pickled objects can contain malicious code they are@potentially vectors for infection. You don’t want to accept persisted@objects from any source you don’t trust.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercises:</p>@<ul>@<li><p>Please create three functions in the same module (file). Each will take two inputs. One file will add the numbers, another will multiply and the third will subtract them.</p></li>@<li><p>Destroy the three functions then recreate them from the serialized files. Verify that they still work as well as the original ones.</p></li>@<li><p>You can use either json or pickle to handle the serialization.</p></li>@</ul></td>@</tr>@</tbody>@</table><S-CR>Classes in Python@=================<S-CR>Classes are where the rubber meets the road. It’s here that all the@concepts we’ve discussed to date coalesce in to useful, reusable@programming product. The real power of class objects stems from the fact@that Python (like most modern languages) is designed to be “object@oriented.” But what does that really mean?<S-CR>Object-oriented languages are built on three tenants:<S-CR>-   Polymorphism<S-CR>-   Inheritance<S-CR>-   Encapsulation<S-CR>… all of which we’ll now discuss in more detail.<S-CR>Polymorphism@------------<S-CR>This is the notion that there can be one interface to the world which,@from the user’s perspective, is the same for accomplishing many things.@The question of just what gets performed and how happens “under the@hood” with the user blissfully unaware. We’ve already encountered that@with respect to the “+” operator.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; "abc" + "bcd"</p>@<p>‘abcbcd’</p>@<p>&gt;&gt;&gt; 1 + 2</p>@<p>3</p>@<p>&gt;&gt;&gt; complex(3,4) + complex(4,4)</p>@<p>(7+8j)</p>@<p>&gt;&gt;&gt; [3,4,5] + [7,8,9]</p>@<p>[3, 4, 5, 7, 8, 9]</p></td>@</tr>@</tbody>@</table><S-CR>Google is another example, writ large. A single input window unleashes@unbelievable computing horsepower, access to petabytes of indexed@information (and targeted ads, but oh well). And who knows what happens@when you hit the “Search” button?<S-CR>Inheritance@-----------<S-CR>Inheritance is the idea that you can create related objects by@separating what they have in common from how they differ. That way, all@the common elements can exist in one and only one place. And the@differentiating element can exist more locally – again in one and only@one place.<S-CR>We’ve already encountered this in examining the exception hierarchy,@repeated here:<S-CR>+-- BaseException<S-CR>+-- Exception<S-CR>+-- StopIteration<S-CR>+-- StopAsyncIteration<S-CR>+-- ArithmeticError<S-CR>\| +-- FloatingPointError<S-CR>\| +-- OverflowError<S-CR>\| +-- ZeroDivisionError<S-CR>All **Exception** objects “inherit” the characteristics of the@**BaseException** – that’s where all the boilerplate and housekeeping@lives. All the exceptions e.g., **ArithmeticError** inherit the@characteristics of **Exception** and add their own special sauce.@Further down the line, the **OverflowError** inherits everything that@the **ArithmeticError** has and further specializes.<S-CR>We’ve seen this already in a really simple form we created a custom@class:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>class WombatException(Exception):</p>@<p>def __str__(self):</p>@<p>return("Wombat!")</p></td>@</tr>@</tbody>@</table><S-CR>In so doing, we inherited from Exception then overrode any existing@**\_\_str\_\_** method – that’s the one that **print** uses – to make it@print out the message.<S-CR>I recognize that all this is a bit abstract so far, so let’s jump into@some code and see what we can do. We can start with something simple.@Here's how we can make a class, inherit from it (create a "subclass"),@and create a specific instance.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>class SuperSimple:</p>@<p>a = 1</p>@<p>class SuperSimpleSubclassed(SuperSimple):</p>@<p>pass</p>@<p>s = SuperSimpleSubclassed()</p>@<p>print("free variable 'a' is {}".format(s.a))</p></td>@</tr>@</tbody>@</table><S-CR>As you can see the instance **SuperSimpleSubclassed**, 's', contains the@object 'a' which came along for the ride from **SuperSimple**. It's a@common practice to have a base class of some sort – this will contain@fundamental functionality and boilerplate code that will become@available to all subordinate classes. Here's a slightly more complicated@example of a base class:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#A base class</p>@<p>class BaseClass:</p>@<p>def __init__(self):</p>@<p>print("BaseClass __init__()")</p>@<p>def shout_out(self):</p>@<p>print('Yo! from BaseClass\n')</p>@<p>def print_something(self, thing):</p>@<p>print("{} from BaseClass \n".format(thing))</p>@<p>base = BaseClass()</p>@<p>base1 = BaseClass()</p>@<p>&gt;&gt;&gt; base.shout_out()</p>@<p>Yo! from BaseClass</p></td>@</tr>@</tbody>@</table><S-CR>Here, we've created two subclasses, **base** and **base1**. These are@independent objects which have their own namespaces. The result is that@each has its own copy of **shout\_out** and **print\_something**. Now,@if we want to extend this class the process is simple. We inherit from@it and add a new method **hello\_child**. We also replace the parent@class' **\_\_init\_\_** method by including a new method of the same@name. In case like this, we may well want to retain access to the parent@class' method. We can do so easily by invoking the **super** method. In@**ChildClass** we execute it to ensure anything introduced into the@namespace by the parent class is also available to the child class.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>class ChildClass(BaseClass):</p>@<p>"simple inheritance, executing parent class __init__()"</p>@<p>def __init__(self):</p>@<p>print("ChildClass __init__()")</p>@<p>super().__init__()</p>@<p>#BaseClass.__init__()</p>@<p>def hello_child(self):</p>@<p>print("hello from ChildClass")</p>@<p>&gt;&gt;&gt; kid = ChildClass()</p>@<p>ChildClass __init__()</p>@<p>BaseClass __init__()</p>@<p>&gt;&gt;&gt; kid.hello_child()</p>@<p>hello from ChildClass</p></td>@</tr>@</tbody>@</table><S-CR>Unlike many languages Python supports multiple inheritance. This makes@it easy to "cherry pick" objects from already-developed code, even from@disparate sources. Here's an example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>class AnotherClass:</p>@<p>def print_something(self, thing):</p>@<p>print("AnotherClass is printing {}\n".format(thing))</p>@<p>class ComboClass1(BaseClass, AnotherClass):</p>@<p>def __init__(self):</p>@<p>#when methods have same name, leftmost is preferred</p>@<p>self.print_something('something')</p>@<p>class ComboClass2(AnotherClass , BaseClass):</p>@<p>def __init__(self):</p>@<p>self.print_something('something')</p></td>@</tr>@</tbody>@</table><S-CR>Python automatically resolves any conflict between methods of the same@name which may exist in multiple inherited classes. The left-most method@trumps the others, so to change the behavior all one has to do is switch@the order.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>&gt;&gt;&gt; combo = ComboClass1()</p>@<p>something from BaseClass</p>@<p>&gt;&gt;&gt; combo = ComboClass2()</p>@<p>AnotherClass is printing something</p></td>@</tr>@</tbody>@</table><S-CR>It's possible to "overload" arithmetic operators by replacing built-in@methods like **\_\_add\_\_** and **\_\_mul\_\_**. Just for fun, here's@how you could create a new version of the **str** object to override how@it handles the "+" sign[63]:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>class newStr(str):</p>@<p>def __init__(self, value):</p>@<p>self.value = value</p>@<p>def __add__(self, other):</p>@<p>return "{}+{}".format(str(self.value), str(other ))</p>@<p>&gt;&gt;&gt; s = newStr('hello')</p>@<p>&gt;&gt;&gt; s</p>@<p>'hello'</p>@<p>&gt;&gt;&gt; news = s+444</p>@<p>&gt;&gt;&gt; news*4</p>@<p>'hello+444hello+444hello+444hello+444'</p></td>@</tr>@</tbody>@</table><S-CR>Only the '+' operator is overridden – the new object retains all of the@other behaviors associated with the built-in **str** object.<S-CR>Let's put all this together, examining some issues around variable@scoping and "ownership" among the different objects. Here's some intact@code, followed by a breakdown of the important bits of it:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_animal_class.py</p>@<p>class Animal:</p>@<p>#class variable (in class namespace)</p>@<p>tricks = ["jumping", "playing dead",</p>@<p>"rolling over", "walking backwards"]</p>@<p>def __init__(self, name, species, age, fav_food):</p>@<p>"sets instance variables (begin with self.)"</p>@<p>self.name = name</p>@<p>self.species = species</p>@<p>self.__dict__["age"] = age # alternative to self.age = age</p>@<p>self.fav_food = fav_food</p>@<p>self.stomach = [ ]</p>@<p>def __str__(self):</p>@<p>fstr="Hi, I'm {}, a {} who loves {}!\n"\</p>@<p>"And I know how to all these things: {}!\n"</p>@<p>return fstr.format(self.name, self.species,</p>@<p>self.fav_food,</p>@<p>" and ".join(self.tricks))</p>@<p>def __repr__(self):</p>@<p>return "Animal(name={}, species={})".</p>@<p>format(self.name, self.species)</p>@<p>#make us a dawg and create an introduction</p>@<p>mypet=Animal("Fang", "dog", 10, "steak")</p>@<p>print(mypet)</p>@<p>#create a cat</p>@<p>neighbor_cat=Animal("Fluffy", "cat", 1, "mice")</p>@<p>print(neighbor_cat)</p>@<p>#override an inherited attribute</p>@<p>neighbor_cat.tricks=['tangling yarn', 'throwing kitty litter']</p>@<p>#Change parent then make new child</p>@<p>Animal.tricks=["barf on floor", "shed on your clothes"]</p>@<p>another_cat=Animal("Snarly", "cat", 100, "rats")</p>@<p>print(another_cat)</p>@<p>print("*****")</p>@<p>#check in on a child with overridden attributes</p>@<p>print(neighbor_cat)</p>@<p>#check in on child with no overrides</p>@<p>print(mypet)</p></td>@</tr>@</tbody>@</table><S-CR>We created Animal by using the keyword **class**.<S-CR>|               |@|---------------|@| class Animal: |<S-CR>Because “Animal” is not followed by any arguments it has not inherited@from any other **class** –we’re starting with a clean slate.<S-CR>Next, we have a “top level”, global-to-**Animal** variable defined.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>tricks = ["jumping", "playing dead",</p>@<p>"rolling over", "walking backwards"]</p></td>@</tr>@</tbody>@</table><S-CR>This variable’s scope is such that it’s visible to any of the class@methods (“functions” when standing alone) within **Animal**.<S-CR>Right below, we see the first instance of a method beginning with a@“dunder.”<S-CR><table>@<tbody>@<tr class="odd">@<td><p>def __init__(self, name, species, age, fav_food):</p>@<p>self.name = name</p>@<p>self.species = species</p>@<p>self.__dict__["age"] = age # same as self.age = age</p>@<p>self.fav_food = fav_food</p>@<p>self.stomach = [ ]</p></td>@</tr>@</tbody>@</table><S-CR>The special name **\_\_init\_\_** signals the interpreter that this@method needs to run when a new instance of the class is created.<S-CR>Note that the constructor (and the constructors for all the methods)@have “self” as the first argument. That’s a stand-in for “this@particular instance of **Animal** – having nothing to do with any other@instance of **Animal**.” In other words “self” refers a specific@manifestation of the general class **Animal**[64]. You can see it in use@in each of the next several statements.<S-CR>Variables like **self.name** and **self.species** are assigned for this@particular instance based on the input arguments provided when an@instance is created, as it might be with a statement like:<S-CR>|                                              |@|----------------------------------------------|@| my\_pet = Animal(“Fang”, “dog”, 10, “steak”) |<S-CR>As names like “**species**”, “**age**”, and “**fav\_food**” are added to@the instance’s namespace, they build up an internal **dict**,@**self**.**\_\_dict\_\_** that contains name: value pairs. While@**self.\_\_dict\_\_** contains references to instance-level objects ,@**mypet** also has access to objects referenced Animal.**\_\_dict\_\_**.@So, for instance, **mypet** knows all about the tricks **Animal** can@do. That’s inheritance at work.<S-CR>When we ask **Fang** about himself:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>fstr = "Hi, I’m {}, a {} who loves {}!"</p>@<p>print(fstr.format(mypet.name, mypet.species, \</p>@<p>mypet.fav_food))</p>@<p>print("And I know how to all these things: {}!"\</p>@<p>.format(" and .”join(mypet.tricks)))</p>@<p>print()</p>@<p>#... we get this:</p>@<p># Hi, I’m Fang, a dog who loves steak!</p>@<p>#And I know how to all these things: jumping and playing</p>@<p>#dead and rolling over and walking backwards!</p></td>@</tr>@</tbody>@</table><S-CR>Remember, we didn’t discuss **tricks** when we created **mypet**. So we@could go on creating all sorts of **Animal** instances – each having the@same repertoire of entertainment options. We can see that if we create@**neighbor\_cat** object.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#create a cat</p>@<p>neighbor_cat = Animal("Fluffy", "cat", 1, "mice")</p>@<p>print(fstr.format(neighbor_cat.name, \</p>@<p>neighbor_cat.species, \</p>@<p>neighbor_cat.fav_food))</p>@<p>print("And I know how to all these things: {}!\n.”\</p>@<p>.format(" and .”join(neighbor_cat.tricks)))</p>@<p>#results</p>@<p>#Hi, I’m Fluffy, a cat who loves mice!</p>@<p>#And I know how to all these things: jumping and</p>@<p>#playing dead and rolling #over and walking backwards!</p></td>@</tr>@</tbody>@</table><S-CR>We can override the tricks **Fluffy** knows, and these changes affect@only **Fluffy**.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>neighbor_cat.tricks = [‘tangling yarn’,</p>@<p>‘throwing kitty litter’]</p>@<p>#...and we can make a change to this instance</p>@<p>print(fstr.format(neighbor_cat.name,</p>@<p>neighbor_cat.species,</p>@<p>neighbor_cat.fav_food))</p>@<p>print("And I know how to all these things: {}!.”\</p>@<p>.format(" and .”join(neighbor_cat.tricks)))</p>@<p>#results:</p>@<p>#Hi, I’m Fluffy, a cat who loves mice!</p>@<p>#And I know how to all these things: tangling yarn</p>@<p>#and throwing kitty litter!</p></td>@</tr>@</tbody>@</table><S-CR>As we can see, instances, and their internal variables are atomic. But@what if we change the parent class **Animal**, then create a new@instance of it? Let’s see.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Animal.tricks = ["barf on floor", "shed on your clothes"]</p>@<p>#... create new instance</p>@<p>another_cat = Animal("Snarly", "cat", 100, "rats")</p>@<p>#...and observe the change to this instance</p>@<p>print()</p>@<p>print(fstr.format(another_cat.name, \</p>@<p>another_cat.species, \</p>@<p>another_cat.fav_food))</p>@<p>print("And I know how to all these things: {}!"\</p>@<p>.format(" and .”join(another_cat.tricks)))</p>@<p>#results</p>@<p># Hi, I’m Snarly, a cat who loves rats!</p>@<p>#And I know how to all these things: barf on floor</p>@<p># and shed on your clothes!</p></td>@</tr>@</tbody>@</table><S-CR>The changes to the **Animal** class have now propagated to a@newly-instanced child class. If we checked in on **Fang** and@**Fluffy**, we would get the following results:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Hi, I’m Fang, a dog who loves steak!</p>@<p>And I know how to all these things: barf on floor and shed on your clothes!</p>@<p>Hi, I’m Fluffy, a cat who loves mice!</p>@<p>And I know how to all these things: tangling yarn and throwing kitty litter!</p></td>@</tr>@</tbody>@</table><S-CR>As you can see, **Fang** has now picked up some very bad habits, and@**Fluffy** still has her instance-level tricks. This points out an@important regarding inheritance. If you explicitly override something@present in the parent class in an instance, that change is persistent in@the instance. However, if you don’t, then the instance will take on that@“something” if the parent class changes. That’s due to the fact that the@instance only looks to the **\_\_dict\_\_** object of the parent if it@needs to (can’t look up the value locally).<S-CR>Encapsulation@-------------<S-CR>This is the notion that there is one and only one way to access an@object. (OK, Python takes a “responsible adults” approach - there is@usually more than one way, but there’s only one correct way).<S-CR>The idea is that objects are atomic, but they have a specific context –@and you’re supposed to interact with them “by the rules.” For example,@some languages use getters and setters to interact with a class’@attributes and enforce that interaction. That way there are specific@points of contact that serve as gateways. As another example, methods@(“verbs”) within a class are only accessible within the context of the@class.<S-CR>Python naturally supports encapsulation by "hiding" variables within the@namespaces of different structures like functions, inner functions,@classes, and modules. A further level of control can be exercised by@employing "getters" and "setters" to control access to instance@variables. Note that Python has no such requirement but sometimes it's a@good idea to lock things down further.<S-CR>To accomplish this, Python employs a special "decorator[65]" called@**property**. Decorators are methods that take the decorated object as@an argument – essentially swallowing the decorated object, much as the@print function can swallow another function using its output as an@argument as in this example:<S-CR>print("hello world".upper())<S-CR>In the following example we define two methods, both named after a@variable we want to manage **val**. The idea is that if **val** is@requested the method under **@property** is executed. If there's an@attempt to change **val** the method under **@val.setter** is executed.@Here, we're using the **setter** to screen out assignment of@inappropriate object types – we're accepting only integer values.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>class GetSet:</p>@<p>def __init__(self):</p>@<p>self._val = None</p>@<p>@property</p>@<p>def val(self):</p>@<p>return self._val</p>@<p>@val.setter</p>@<p>def val(self, value):</p>@<p>if isinstance(value, int):</p>@<p>self._val = value</p>@<p>print("OK. Thanks for giving me " + str(value))</p>@<p>else:</p>@<p>print("Sorry, I'm looking for an integer \</p>@<p>but you gave me " + str(value))</p>@<p>&gt;&gt;&gt; gs = GetSet()</p>@<p>&gt;&gt;&gt; gs.val = 3</p>@<p>OK. Thanks for giving me 3</p>@<p>&gt;&gt;&gt; gs.val = "aardvark!"</p>@<p>Sorry, I'm looking for an integer but you gave me aardvark!</p></td>@</tr>@</tbody>@</table><S-CR>This is pretty detailed, and well beyond what you’ll find in most@beginner classes. Hopefully, though, it will give you great background@as you wade in.<S-CR>Let’s put some of this to work and build some classes as an exercise@(nothing too detailed, I promise!)<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise:</p>@<p>Please build a hierarchal class structure to represent some transportation. Your code should include the following:</p>@<p>Vehicle (has a wheels attribute to keep a count)</p>@<p>MotorVehicle (inherits from Vehicle, adds a motor)</p>@<p>Car (inherits from MotorVehicle, has four wheels, adds has_AC attribute)</p>@<p>MotorCycle (inherits from Motor Vehicle, two wheels,</p>@<p>adds has_fairing attribute)</p>@<p>Please include a <strong>__str__</strong> method for each.</p></td>@</tr>@</tbody>@</table><S-CR>Regular Expressions@===================<S-CR>Regular expressions (also known as REs or regexes) offer a very@low-level way to process text, very efficiently. You’ll run into them as@a matter of course in Perl, Linux command line search tools, Django URL@resolvers, etc.) While powerful, the offer some of the least@transparent, horrifically-hard-to-read statements ever. IMHO, anyway. So@we’ll build up gradually and your confidence in using them should@materialize quickly.<S-CR>Python support is contained in the **re** library, and in the normal@**help** facility. A really excellent online resource can be found at@https://regex101.com/\#python[66]. It provides an interactive way to@build your regex, test it against a string, view matches and – best of@all – provides a breakdown of exactly what each step of your regex is@doing.<S-CR>Begin at the beginning@----------------------<S-CR>For starters, let’s just look for a string inside another string. For@this you need a regex string to describe what you’re looking for and@another string to search.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_regex_1.py</p>@<p>import re</p>@<p>regex = r‘x’ #what we’re looking for</p>@<p>target = r‘Texas’</p>@<p>result = re.search(regex, target)</p>@<p>if result:</p>@<p>print("Yay! {} found..”.format(regex))</p>@<p>print("The found object is: {}.”.format(result))</p>@<p>#result</p>@<p>#Yay! x found.</p>@<p>#The found object is: &lt;_sre.SRE_Match object;</p>@<p>span = (2, 3), match = ‘x’&gt;</p></td>@</tr>@</tbody>@</table><S-CR>As you can see, this returned a **SRE\_Match** object. The fact that it@returned anything means that we hit pay dirt by finding at least one@match.<S-CR>Character Sets@--------------<S-CR>If you want to look for any one of a bunch of characters, you can use@what’s known as a “character set.” It’s just a string that includes@surrounding square brackets. Any of these work: ‘\[abc\]’ ; ‘\[12345\]’;@‘\[1-4\]’. Here are some examples:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_regex_2.py</p>@<p>import re</p>@<p>regex = ( r"[0123456789]" , #all digits</p>@<p>r"[0-9]", #shorthand for all digits</p>@<p>r"[abc]" , #any of a, b, or c</p>@<p>r"[abc] [abc] [abc]", #3 consecutive letters,</p>@<p># a or b or c</p>@<p>r"[^0-9]", #NOT a digit (the ^ in</p>@<p>#first position negates</p>@<p>)</p>@<p>target = (r‘Texas’, r‘123’, r"a", r"abc")</p>@<p>for r in regex:</p>@<p>for t in target:</p>@<p>result = re.search(r, t)</p>@<p>if result:</p>@<p>print("{:10} matched with {:10}.”.format(t, r))</p>@<p>result = None</p></td>@</tr>@</tbody>@</table><S-CR>Special Symbols@---------------<S-CR>This is pretty easy so far, right? Regular expressions use a lot of@special characters which are shorthand for matching rules. You’ve got to@escape them with the “\\” if you intend to use them literally. We’ll@visit them pretty soon, but for now, here they are:<S-CR>|                                |@|--------------------------------|@| \[ \] ( ) { } + \*/ ? \$ ^. \| |<S-CR>Shortcuts@---------<S-CR>Since people are looking for the same strings all the time there are@some clichés / shortcuts available. The general form is a slash followed@by a letter. If the letter is lower case, it’s an “affirmative” search;@if upper case, it’s a “negative” search. Here are a few:<S-CR>| \\d any digit             | \\D anything but a digit           |@|---------------------------|------------------------------------|@| \\w any digit or letter   | \\W anything but a digit or letter |@| \\s any whitespace        | \\S anything but a whitespace      |@| . (a dot) anything        |                                    |@| ^ match only at beginning | \$ match only at the end           |<S-CR>Additionally, there are shortcuts that keep you from repeating bits of@your regex string when you’re looking for multiple instances of the same@thing. Here are some short hand expressions for specific quantities:<S-CR><table>@<thead>@<tr class="header">@<th>*</th>@<th>0 or more</th>@</tr>@</thead>@<tbody>@<tr class="odd">@<td>?</td>@<td>0 or 1</td>@</tr>@<tr class="even">@<td>+</td>@<td>1 or more</td>@</tr>@<tr class="odd">@<td>{x}</td>@<td>Exactly x</td>@</tr>@<tr class="even">@<td>{x,y}</td>@<td><blockquote>@<p>Between x and y, inclusive of x and y</p>@</blockquote></td>@</tr>@<tr class="odd">@<td>{x, }</td>@<td>X or more</td>@</tr>@</tbody>@</table><S-CR>Here are some examples:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_regex_3.py</p>@<p>import re</p>@<p>regex = ( r"cu" , #’cu’</p>@<p>r"0{\d4}", #4 digits</p>@<p>r"x{1,3}" , #1,2, or 3 ‘x’</p>@<p>r"0{2,}", #2 or more zeros</p>@<p>r"\W+", #contains at least one</p>@<p>#non alphanumeric</p>@<p>)</p>@<p>target = (r‘Chicago Cubs’, r‘1000000 dollars’,</p>@<p>r"xxxooo", r"$2500K")</p>@<p>for r in regex:</p>@<p>for t in target:</p>@<p>result = re.search(r, t)</p>@<p>if result:</p>@<p>print("{:10} matched with {:10}"\</p>@<p>.format(t, r))</p>@<p>result = None</p>@<p>"""</p>@<p>results</p>@<p>xxxooo matched with x{1,3}</p>@<p>1000000 dollars matched with 0{2,}</p>@<p>$2500K matched with 0{2,}</p>@<p>Chicago Cubs matched with \W+</p>@<p>1000000 dollars matched with \W+</p>@<p>$2500K matched with \W+</p>@<p>"""</p></td>@</tr>@</tbody>@</table><S-CR>Match objects and compiled regexes@----------------------------------<S-CR>It’s possible to compile your regex to increase performance – this is@especially useful if you plan to use it thousands of times because it@doesn’t have to happen “on demand” each time.<S-CR>You can query the match objects to find starting and ending positions.@This is useful if you want to use indices to retrieve content around@particular phrases.<S-CR>The following example demonstrates some of the information you can@retrieve and the use of **re.compile**:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_regex_4.py</p>@<p>import re</p>@<p>regex = r"Cubs"</p>@<p>target = r‘Chicago Cubs’</p>@<p>compiled = re.compile(regex)</p>@<p>result = compiled.search(target)</p>@<p>if result:</p>@<p>print("{:10} matched with {:10}.” \</p>@<p>.format(target, regex))</p>@<p>print("span", result.span())</p>@<p>print("start", result.start())</p>@<p>print("end", result.end())</p></td>@</tr>@</tbody>@</table><S-CR>Finally, I’d like to point out that re has a **VERBOSE** mode that@allows you to stretch complicated expressions (yes, they can get really@complicated) across several lines. When you do so, it’s possible to@provide comments to help your teammates decipher just what it’s intended@to do.<S-CR>Here’s an example borrowed from *Dive into Python*[67], to illustrate@its use. This regex is used to validate Roman numerals.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_roman_regex.py</p>@<p>Pattern = “””</p>@<p>^ # beginning of string</p>@<p>M{0,4} # thousands - 0 to 4 M’s</p>@<p>(CM|CD|D?C{0,3}) # hundreds - 900 (CM), 400 (CD),</p>@<p># 0-300 (0 to 3 C’s), or 500-800</p>@<p># (D, followed by 0 to 3 C’s)</p>@<p>(XC|XL|L?X{0,3}) # tens - 90 (XC), 40 (XL), 0-30</p>@<p># (0 to 3 X’s),</p>@<p># or 50-80 (L, followed by 0 to 3</p>@<p># X’s)</p>@<p>(IX|IV|V?I{0,3}) # ones - 9 (IX), 4 (IV), 0-3</p>@<p># (0 to 3 I’s), or 5-8 (V,</p>@<p># followed by 0 to 3 I’s)</p>@<p>$ # end of string</p>@<p>"""</p>@<p>re.search(pattern, ‘M’, re.VERBOSE)</p></td>@</tr>@</tbody>@</table><S-CR>Substitution@------------<S-CR>You can use regexes to do string substitutions using the **re.sub**@method. Here’s an example:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_regex_5.py</p>@<p>import re</p>@<p>re.sub</p>@<p>regex = ‘cubs’</p>@<p>change_to = "CUBS"</p>@<p>target = ‘If the cubs actually win again, \</p>@<p>will they still be the cubs?’</p>@<p>result = re.sub(regex, change_to, target)</p>@<p>if result:</p>@<p>print(result)</p>@<p>#result</p>@<p># If the CUBS actually win again, will they still be the CUBS?</p></td>@</tr>@</tbody>@</table><S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise</p>@<p>Please write a regex that will convert credit card numbers from their original form (4-four digit numbers) to a safer form like xxxx-xxxx-xxxx-3423. Use regex101.com to guide your efforts and test your work.</p></td>@</tr>@</tbody>@</table><S-CR>1.  ####### <S-CR>2.  ####### . (Really) Brief Introduction to Unit Testing<S-CR>Strictly speaking, unit testing is outside the scope of this@introductory course. But it’s a really important topic and I’d like you@to have at least a rudimentary understanding of it.<S-CR>You now know how to write Python code and make sure it works. You can@use debug **print** statements to keep track of what your project is@doing. This is all fine and good, but how do you know that your latest@enhancement hasn’t broken a bit of your already-tested code? How can@your teammates, who may be applying a bit of healthy skepticism, know@that it works as advertised without a lot of digging around? That’s@where unit testing comes into play.<S-CR>Here are the basics:<S-CR>-   import **unittest**<S-CR>-   subclass **unittest**.**TestCase**<S-CR>-   within the subclass, write assertions about what your code should@    produce<S-CR>Pretty easy, right? You can create your unit tests within the module@you’re testing so everything is conveniently in one place. More@commonly, though, you’ll create a separate module for the tests and@import the bits of code that the tests will evaluate.<S-CR>Here’s a concrete example. You’ll remember that we can use the **get**@method of the **dict** object to return a valid object even if we query@the **dict** with an invalid key. Part of the code we looked at appears@below:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_get.py</p>@<p>"use the dict method get()"</p>@<p>plant_dict = {‘raspberry’: ‘rubus’,</p>@<p>‘elm’ : ‘ulmus’,</p>@<p>‘maple’ : ‘acer’ }</p>@<p>fmt_str = "The {} is more properly called a {}."</p>@<p>#get() with a default value</p>@<p>look_for = ‘alder’</p>@<p>default = ‘SOMETHING. I dunno’</p>@<p>found = plant_dict.get(look_for, default)</p>@<p>print(fmt_str.format(look_for, found))</p></td>@</tr>@</tbody>@</table><S-CR>We used a simple **print** statement to see what **get** returned, and@that worked just fine. You’ll recall that we tested **get** with a@**None** default value, a string default, and no value at all when we@were sure the **dict** knew about the key we tried. Using **unittest**,@we could have done something like:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_basic_unittest.py</p>@<p>import unittest</p>@<p>plant_dict = {‘raspberry’: ‘rubus’,</p>@<p>‘elm’ : ‘ulmus’,</p>@<p>‘maple’ : ‘acer’</p>@<p>}</p>@<p>look_for = ‘alder’</p>@<p>default = ‘SOMETHING. I dunno’</p>@<p>class tester(unittest.TestCase):</p>@<p>def test_found_OK(self):</p>@<p>self.assertEqual(plant_dict.get(‘elm’),’ulmus’)</p>@<p>def test_not_found_None(self):</p>@<p>self.assertEqual(plant_dict.get(‘sumak’, None),\</p>@<p>None)</p>@<p>def test_not_found_string(self):</p>@<p>self.assertEqual(plant_dict.get(‘ash’, ‘no_ash’),\</p>@<p>‘no_ash’)</p>@<p>unittest.main()</p></td>@</tr>@</tbody>@</table><S-CR>If you look at the methods found in the class tester, you’ll see that@we’ve been able to accomplish precisely the same verification of the@**get** function that we saw in the example code. The difference now is@that these tests run automatically and ensure that **get** works just as@expected.<S-CR>This is a trivial example. As a matter of course you probably won’t be@spending time writing your own tests against built-in functionality. You@can rest assured that that the developers of the Python core did exactly@that already. But with your own code … well, that’s a different story@altogether.<S-CR>Let’s try something more realistic. Say you got a task to write a@function that tried to figure out whether the user provided something@that looks like an integer. If possible, it will test the input to check@if it’s odd, and if so return twice the value. Otherwise it will return@a **None** object.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_basic_unittest_1.py</p>@<p>def odd_man_out(inp):</p>@<p>"""If input looks like an odd integer, return</p>@<p>twice its value; otherwise, return None"""</p>@<p>try: #Is it a number at all? If not, give up.</p>@<p>inp/1</p>@<p>except:</p>@<p>return None</p>@<p>try: #If it’s a number, can we cast as an integer?</p>@<p>inp = int(inp)</p>@<p>except:</p>@<p>return None</p>@<p>#If it’s a number, is it odd?</p>@<p>if inp % 2: #returns 0 if even</p>@<p>return(inp*2)</p>@<p>if __name__ = = ‘__main__’:</p>@<p>import unittest</p>@<p>class tester(unittest.TestCase):</p>@<p>def test_odd_integer(self):</p>@<p>self.assertEqual(odd_man_out(3), 6)</p>@<p>def test_even_integer(self):</p>@<p>self.assertEqual(odd_man_out(4), None)</p>@<p>unittest.main()</p></td>@</tr>@</tbody>@</table><S-CR>This yields the following output, showing that it works as expected:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>..</p>@<p>------------------------------------------------------</p>@<p>Ran 2 tests in 0.008s</p>@<p>OK</p></td>@</tr>@</tbody>@</table><S-CR>Anyway, that’s what it looks like at first glance. However, we haven’t@really checked any “corner conditions”, have we? Since we’re accepting@user input, anything can happen and it’s worth prodding our function a@bit. When we use unit tests, that becomes easy – all we need to do is@add a few more tests. Here are some we might investigate:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>#py_basic_unittest_2.py</p>@<p>#&lt;snip&gt;</p>@<p>def test_odd_string(self):</p>@<p>self.assertEqual(odd_man_out(‘123’), 246)</p>@<p>def test_odd_float(self):</p>@<p>self.assertEqual(odd_man_out(30.0), 60.0)</p>@<p>def test_list(self):</p>@<p>self.assertEqual(odd_man_out([1,2,3]), None)</p>@<p>def test_complex(self):</p>@<p>self.assertEqual(odd_man_out(complex(1,2)), None)</p></td>@</tr>@</tbody>@</table><S-CR>Now we can check if the function did what it could to type-cast input@into an **int** type, and whether it did well with a **list** object@which it probably won’t be able to convert, and a **complex** type which@it might.<S-CR>When we run the intact routine, we’ll see that our new tests have blown@up, revealing weaknesses in our code. While that might seem like a bad@thing, it’s really not. We’ve spared ourselves an angry late-night phone@call from a client (or worse). More importantly, we get some solid@information about what the issues are and exactly where to track them@down. Here’s the output:<S-CR><table>@<tbody>@<tr class="odd">@<td><p>...F.F</p>@<p>FAIL: test_odd_float (__main__.tester)</p>@<p>------------------------------------------------------</p>@<p>Traceback (most recent call last):</p>@<p>File "/home/pat/workspace/python_course_pat/</p>@<p>py_basic_unittest_2.py",</p>@<p>line 28, in test_odd_float</p>@<p>self.assertEqual(odd_man_out(30.0), 60.0)</p>@<p>AssertionError: None ! = 60.0</p>@<p>FAIL: test_odd_string (__main__.tester)</p>@<p>------------------------------------------------------</p>@<p>Traceback (most recent call last):</p>@<p>File "/home/pat/workspace/python_course_pat/</p>@<p>py_basic_unittest_2.py",</p>@<p>line 26, in test_odd_string</p>@<p>self.assertEqual(odd_man_out(‘123’), 246)</p>@<p>AssertionError: None ! = 246</p>@<p>------------------------------------------------------</p>@<p>Ran 6 tests in 0.013s</p>@<p>FAILED (failures = 2)</p></td>@</tr>@</tbody>@</table><S-CR>Unit testing is (or can be) much more complex than presented here – and@the library gives you myriad options to customize testing to fit your@code like a glove. Some of the things you can do are:<S-CR>choose all kinds of **TestCase** tests like **assertIsInstance**,@**assertGreater**, **assertDictContainsSubset** and dozens more.<S-CR>-   specify methods to run before and after each test to set up the@    right environment;<S-CR>-   specify ‘negative tests’ that will test out-of-specification@    conditions without crashing your test suite.<S-CR>Full documentation is available here:<S-CR><https://docs.python.org/3.5/library/unittest.html><S-CR>… and is highly recommended.<S-CR><table>@<tbody>@<tr class="odd">@<td><p>Exercise:</p>@<ul>@<li><p>Please use these unit tests to guide your efforts to debug and otherwise perfect the py_basic_unittest_2.py code. Add any other tests that you think will be useful to make it reliable.</p></li>@<li><p>Please write some <strong>unittests</strong> against the screener method from the solution to Chapter 7 (solution_python1_chapter07_screener.py). Then try to streamline the code, testing frequently as you do so.</p></li>@</ul></td>@</tr>@</tbody>@</table><S-CR>Congratulations!!!<S-CR>You have now completed Introduction to Python 3. You’re well-equipped to@take on the pleasant challenge of reinforcing your understanding with@hands-on projects.<S-CR>My friendly advice at this point would be to do just that. Get your@hands dirty working with some real code, optimally with some seasoned@Python programmers. Courses are great because they provide a lot of@information over a short period of time. But it’s not until you apply@the information, bang your head against the wall, iteratively ask and@answer questions, and finally succeed, that you will really understand@it.<S-CR>Don’t have a coding project at work? You might check out your local@Python user’s group. Many of them have “adopted” a charity for whom they@do *pro bono* development. Others organize sprints to enhance open@source projects (don’t worry – beginners are always welcome). Still@others have meet-ups designed precisely to get seasoned programmers@together with new ones, quite often involving electrolytic replacement@liquids.<S-CR>If you’re a lady, or know one who’s interested, you might check out@PyLadies:, a group focused upon helping women become engaged with Python@and the open-source community generally. They hang out at pyladies.com.<S-CR>Best of luck to you in what I hope will be an enjoyable programming@career!<S-CR>Acknowledgements<S-CR>I would like to thank Kirby Urner of 4D Solutions (4dsolutions.net) for@his valuable support, for contributing some of the material presented@here, and always wise council. In particular, I would like to thank him@for introducing me to Python lo, so many years ago.<S-CR>I would also like to thank Steve Holden, past president of the Python@Software Foundation for his moral support, code contributions and his@wise council.<S-CR>Thanks, especially to the thousands of people who have gifted Python to@a grateful world.<S-CR>About the Author<S-CR><img src="attachment:media/image5.png" style="width:1.62292in;height:1.64931in" />Patrick@Barton has been wrangling Python since 2010, applying it mostly to@mathematical modeling and machine learning projects. He was the Lead@Instructor at the O’Reilly School of Technology, where he was also a@full-course Python instructor.<S-CR>In past lives, he has served as a National Laboratory energy scientist,@VP of research and development for a psychometric research organization,@and inventor of the first artificially-intelligent trapping system for@Burmese pythons (Python-based, naturally).<S-CR>He makes his home in Portland, Oregon. You can connect with him on@LinkedIn: https://www.linkedin.com/in/patbartonpdx<S-CR>[1] www.pydev.org/manual\_101\_install.html<S-CR>[2] http://wingware.com/downloads This is a commercial product. If you@decide to buy it, this discount code will get a substantial savings:@PJBD50A1.<S-CR>[3] No need to memorize these – we’re just showing how simple the@underlying language is.<S-CR>[4] You may want to familiarize yourself with the **inspect** library.@It has dozens of tools like **getargspec** (finds arguments accepted by@a function with their default values), **getmodule** (returns the module@an object was defined in), and **getsource** (returns the source code).@If you’re using an IDE, you might find that some of these are wrapped up@and made available via the IDE’s graphical interface. It’s easy enough@to go:<S-CR>\>\>\> import inspect<S-CR>\>\>\> help(inspect)<S-CR>[5] If you’re interested in exploring these@../experimental/py\_precision.py has examples. If you go on to use@elements from Python’s scientific stack e.g., **numpy**, you’ll be using@the numeric types supported by your C compiler. These will typically be@limited to 64 bits in modern machines. Cf.@https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html<S-CR>[6] Note all the things we did NOT have to do: declare the looping@variable s; find the length of the object; move the pointer along the@sequence; ensure we don’t run the pointer “off the edge” of the object.@This is all handled by methods defined as part of the object.<S-CR>[7] An “indented suite” is just a \$20 word for all the lines of code@beneath a header (the **for** statement in this case) that’s indented@the same number of spaces. This is considered the “code block”@associated with the header.<S-CR>[8] We’re going into quite a bit of detail on string objects here –@partly because they’re might useful and partly because they are@exemplars of all other Python objects you’ll encounter.<S-CR>[9] You can think of opposing parentheses as the “execution operator”,@much as + is (usually) the “addition operator”. Note that the function@won’t execute without the ():<S-CR>\>\>\>'777'.isalnum<S-CR>\<built-in method isalnum of str object at 0x000002575B764998\><S-CR>\>\>\> '777'.isalnum()<S-CR>True<S-CR>[10] A **list** is a built-in Python object. It’s an ordered sequence@that may contain heterogenous elements, something like: \[ ‘one’, 2,@3.0, (4 + 5j) \] Note the square brackets. More on the **list** object@later.<S-CR>[11] An “iterable object” is something you can use a for or next@operation on – it knows how to loop over itself.<S-CR>[12] With no arguments, it splits on anything in the same time zone as a@white space (tabs, new line characters, and white spaces).<S-CR>[13] A **tuple** is the same as a list except it’s “immutable”@(unchangeable). It has parenthesis, something like:<S-CR>( ‘one’, 2, 3.0, (4 + 5j) )<S-CR>[14] The opposite of **chr** is **ord**. Thus **chr**(90) is ‘Z’ and@**ord**(‘Z’) is 90.<S-CR>[15] **None** is an honest-to-goodness Python object. It doesn’t do@much, but you can assign a name to it and use the name as you would that@of any other variable.<S-CR>[16] You’ll find **in** used in several contexts (as with the **for**@statement). It invokes the **\_\_contains\_\_** method to determine@membership.<S-CR>[17] **replace** changes all occurrences by default. If you provide an@optional parameter count, you can limit the number of replacements:<S-CR>\>\>\> 'aaa'.replace('a', 'A', 2)<S-CR>'AAa'<S-CR>[18] The **lstrip** method removes whitespaces on the left, **rstrip**@on the right, and **strip** from both ends.<S-CR>[19] This section can be skipped without loss of continuity, but may be@worth a quick glance.<S-CR>[20] Back in the day, one had to provide more specific placeholders like@%s, %i, and %f for strings, integers and floating point numbers. In@fact, Python will still accept these “legacy” specifications. This@works:<S-CR>\>\>\> "%s %s" %('Hey', 'Joe!')<S-CR>'Hey Joe!<S-CR>[21] The most common alignment choices are left (\<), right (\>), or@center(^).<S-CR>[22] <https://docs.python.org/3/library/string.html#format-string-syntax>@It may be well worth your while to take a moment with the docs to get an@idea for the breadth of options available. Dozens of examples appear at@the bottom that will serve as recipes for complex formatting chores.<S-CR>[23] “Unpacking” is a common Python idiom – you can create new names and@assign members of a sequence as their values using this sort of@shorthand (works on lists, tuples, strings, etc.):<S-CR>\>\>\> first, second = "AB"<S-CR>\>\>\> print(first, second)<S-CR>A B<S-CR>[24] https://www.python.org/dev/peps/pep-0008<S-CR>[25] As a consequence, be sure to put general “catch all” tests at the@bottom of your block – otherwise they could block execution of the@contents of more specific tests.<S-CR>[26] You might want to step through this **while** loop a line at a time@in a debugger, as well as the others encountered in this chapter, to@observe which lines get executed – and in what order.<S-CR>[27] Python supports lots of permutations of this including -= \*= /=@and %=.<S-CR>[28] You can think of a binary shift as increasing or decreasing a@binary number by a power of 2. In the base 10 world it’s like going 1.2@\* 10\*\*2 = 120 … 1.2 \* 10\*\*3 = 1200 … 1.2 \* 10\*\*4 = 12000. As@you increase to power of 10, you just tack on a zero because you’re@shifting the “1.2” by increasing orders of magnitude.<S-CR>[29] A **set** is a collection of zero or more unique objects. More on@the **set** object later.<S-CR>[30] This is convenient, but has performance issues at scale – the@interpreter has to be prepared to constantly adjust things, and that@means lots of relatively expensive memory allocation operations. If@you’re considering a project that could deal with large amounts of data@consider using immutable sequences (**tuples** and **strings**) where@possible and/or objects that impose heterogenous elements e.g.,@**array.array** or **numpy.ndarray** objects.<S-CR>[31] It’s helpful to think of the “stop” parameter like a real-world@stop sign. You don’t roll through it, but stop before it. Though a bit@strange at first, this specification is handy because iterable\[:2\] and@iterable\[2:\] are complementary “halves” of the entire object.<S-CR>[32] The collections library contains some great tools not covered here@including **defaultdict** (a **dict**-like object that automatically@installs a new key:default\_value pair if the key doesn’t exist) and@**deque** (a double-ended queue useful for managing processes and@threads).<S-CR>[33] Generally a hash is a computer science term for the eponymous data@structure. There’s a very approachable article in Wikipedia, in case@you’re interested: https://en.wikipedia.org/wiki/Hash\_function<S-CR>[34] If you accidentally use a mutable (changeable) object you’ll get a@nearly-indecipherable error message, something like: builtins.TypeError:@unhashable type: 'list'<S-CR>[35] You may have noted that Python objects don’t have destructor@methods, as you find in many other languages. The **del** method is a@general purpose tool for destroying unwanted objects. You typically@don’t need to worry about this because Python has built-in “garbage@collection”. Objects that are dereferenced get destroyed automatically.<S-CR>[36] NB **sort** is a method belonging to the **list** object. It’s an@“in-place” operation – that means that the elements are simply shifted@around and no new object is created. As a result, it returns a **None**@object. The **sorted** function is a built-in that will work on any@iterable. It creates and returns a new **list** object.<S-CR>[37] It’s easy to build a list comprehension if you do it in stages:<S-CR>\>\>\> \[ \] \#empty list<S-CR>\[ for i in range(3) \] \#add an iterating expression<S-CR>\[ i for i in range(3) \] \#add the thing that goes into the list<S-CR>\[ i for i in range(3) if i %2 \] \#add a filter (anything that produces@a Boolean)<S-CR>\[1\]<S-CR>[38] Cf. https://en.wikipedia.org/wiki/Chess\_symbols\_in\_Unicode<S-CR>[39] Python 2.x can use Unicode, but it’s “by request only”.<S-CR>[40] You can view the global namespace (really a **dict** mapping names@and values) using **globals()**. In some IDEs the function names are not@shown in stack data.<S-CR>[41] You can view the local namespace using **locals()**. The local@namespace will change as the execution moves from function to function.<S-CR>[42] You may want to experiment by removing and replacing the comment in@**setStar**.<S-CR>[43] Note the use of the keyword **pass**. This is a placeholder whose@only job is to take up space – enough to establish indentation.<S-CR>[44] In some languages, like Java, functions don’t really have a meaning@outside the context of a containing class; they’re known as “class@methods”.<S-CR>[45] Simple **lambda** functions can add readability to your code@because they can be defined geographically close to where they’re being@applied. Though they’re only “one liners” they can be arbitrarily@complex and really difficult for your teammates to figure out. Sometimes@it’s much more transparent to use a traditional function.<S-CR>[46] You can check an annotated version to find out:@py\_function\_7\_upgraded.py<S-CR>[47] As an aside (just for fun) the epoch “odometer” will “roll over”@for 32 bit Linux systems on January 19, 2038. This could be interesting@if any of these machines still exist. If you have a 64-bit system, you@can relax. The rollover won’t happen until sometime in the year@292,277,026,596.<S-CR>[48] Cf. https://docs.python.org/3/library/datetime.html<S-CR>[49] There is also an “opposite” method that will convert a string into@a **datetime** object using the same codes – it’s called **strptime.**<S-CR>[50] http://strftime.org/<S-CR>[51] If you get serious about wrangling dates you’ll want to consider@using **pandas**. The basic **pandas** object Series is essentially a@**list** on steroids. Like a **list** it has a 0-based integer index.@But you can “bolt on” an index of any other data type, including dates.@When you do, pandas knows how to “stretch” it from days to weeks,@interpolate missing values any way you ask, etc. It is aware of business@days, holidays, etc. Well worth the investment to learn, IMHO.<S-CR>[52] You might want to use help() on the **TextCalendar** object@produced in this script. It knows how to return specific months, week,@or years as printable calendar snippets, as iterators, or as lists of@**datetime** objects.<S-CR>[53] The **os.path** package has several useful methods for teasing@apart path names, joining them with the correct separators, determining@if specific file system objects exist, etc. The **shutil** library has@several methods for working with macro-scale file system manipulations@like moving entire directory trees.<S-CR>[54] If you’re running this code in a debugger like WingIDE, the@debugger may stop execution inappropriately when an exception is@encountered. If this happens, ask the debugger to ignore this exception.@In Wing, there’s a checkbox in the Exceptions tab for this purpose.<S-CR>[55] https://docs.python.org/3/library/exceptions.html\#exception-hierarchy<S-CR>[56] It’s worthwhile taking a quick look at the namespace of the@traceback library – it has many tools you can use when doing text-only@debugging (these get wrapped up in tools like Exceptions and Call Stack@when using an IDE).<S-CR>[57] There is a more elaborate example in py\_handler\_practice.py, in@case you’re interested in playing around with it.<S-CR>[58] The ‘r’ mode is the default. Strictly speaking you don’t need to@specify it.<S-CR>[59] Alternatively, you can use the **subprocess** library. This give@you the ability to spawn new processes with which you can invoke bash@scripts, execute system programs, and anything else you might do at the@command line. For instance, you can go:<S-CR>\>\>\> import subprocess<S-CR>\>\>\> subprocess.call('dir', shell=True) \#subprocess.call(‘ls -l’,@shell=True)<S-CR>… but you can paint yourself into a corner vis-à-vis OS portability.@Complete docs are here:<S-CR>https://docs.python.org/3/library/subprocess.html<S-CR>[60] Java Script Object Notation – an XML like, human-readable format.<S-CR>[61] You can use **time.time** or, with a bit more effort use **timeit**@if you want to experiment. The official docs for the latter can be found@here: https://docs.python.org/3/library/timeit.html)<S-CR>[62] https://docs.python.org/3/library/pickle.html<S-CR>[63] NB: You would likely never do this in practice. Just because you@can, doesn’t mean you should :-)<S-CR>[64] You don’t have to use ‘self’. You could use ‘aardvark’ if you@wanted, but people would look at you funny ;-)<S-CR>[65] You’ll find some more examples of decorators and their uses in your@course file director, all with names beginning with py\_decorators.<S-CR>[66] Be sure to set it to the Python dialect of regex (there are@several). The “cheat sheet” at the bottom right – shows what all the@tokens mean. As you build your regex, a complete explanation of it shows@up in the upper right. It’s not so easy to see, but on the left there’s@a button that will produce syntactically-correct Python code based on@your explorations. This is my “go to” tool for all things regex.<S-CR>[67] diveintopython.net – an awesome, well-documented, open source book@designed for advanced programmers. It’s a good read as you advance along@the path of becoming one.@
